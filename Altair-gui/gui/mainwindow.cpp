#include "altair.h"



/* AUTHOR NOTE




mainWindow.cpp  - Main Window for altair-author-gui

This application uses Qt5.1 . Check Qt's licensing details on http://qt.nokia.com


Copyright Fabrice Nicol <fabnicol@users.sourceforge.net> Feb 2009,2011-2013

The latest version can be found at http://dvd-audio.sourceforge.net

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/


// createFontDataBase looks to be fast enough to be run on each launch.
// Should it slow down application launch on some platform, one option could be to launch it just once then on user demand




MainWindow::MainWindow(char* projectName)
{


  setGeometry(QRect(200, 200,1150,400));
  recentFiles=QStringList()<<QString("defaut") ;

  altair=new Altair;

  dialog=new options(altair);

  dialog->setParent(altair, Qt::Window);
  altair->parent=this;
  altair->projectName=projectName;

  console=new Console(this);

  connect(&(altair->process),   &QProcess::started,     [&]  {  feedConsole(); });

  createActions();
  createMenus();

  settings = new QSettings("altair", "Free Software Inc");

  if ((settings->value("defaut").isValid())
                &&
     (!settings->value("defaut").toString().isEmpty()))
        altair->setCurrentFile(settings->value("defaut").toString());
  else
    {
        altair->setCurrentFile(projectName);
        settings->setValue("defaut",projectName);
    }


  setCentralWidget(altair);

  altair->addActions(actionList);
  altair->setContextMenuPolicy(Qt::ActionsContextMenu);
  altair->setContextMenuPolicy(Qt::ActionsContextMenu);

  bottomDockWidget=new QDockWidget;
  bottomTabWidget=new QTabWidget;
  consoleDialog=  new QTextEdit;
  //consoleDialog->setMinimumSize(800,600);
  bottomTabWidget->addTab(altair->outputTextEdit, tr("Messages"));

  fileTreeViewDockWidget= new QDockWidget;
  fileTreeViewDockWidget->setWidget(altair->fileTreeView);
  fileTreeViewDockWidget->setMinimumHeight((unsigned) (height()*0.3));
  fileTreeViewDockWidget->setFeatures(QDockWidget::AllDockWidgetFeatures);
  fileTreeViewDockWidget->hide();
  addDockWidget(Qt::LeftDockWidgetArea, fileTreeViewDockWidget);

  managerDockWidget= new QDockWidget;
  managerDockWidget->setWidget(altair->managerWidget);
  managerDockWidget->setMinimumHeight((unsigned) (height()*0.3));
  managerDockWidget->setFeatures(QDockWidget::AllDockWidgetFeatures);
  managerDockWidget->show();
  addDockWidget(Qt::RightDockWidgetArea, managerDockWidget);
  
  Abstract::initializeFStringListHashes();
  //altair->RefreshFlag =0;
  Abstract::refreshOptionFields();
        //altair->RefreshFlag = ParseXml for poorly understood reasons
  // do not put before as we want to control RefreshFlag in a connection generated by configureOptions

   configureOptions();
   createToolBars();
   
  // NOTE: Using only FCheckBoxes. Change this if other FAbstractWidget subclasses are to be used

  for (FCheckBox* a : displayWidgetList+behaviorWidgetList)
      {
         if (settings->value(a->getHashKey()).isValid())
             a->setChecked(settings->value(a->getHashKey()).toBool());
      }


  altair->initializeProject();
  bottomTabWidget->setCurrentIndex(0);

  QToolButton *clearBottomTabWidgetButton=new QToolButton;
  const QIcon clearOutputText = QIcon(QString::fromUtf8( ":/images/edit-clear.png"));
  clearBottomTabWidgetButton->setIcon(clearOutputText);

  connect(clearBottomTabWidgetButton, &QToolButton::clicked, [this] { on_clearOutputTextButton_clicked();});

  QGroupBox *stackedBottomWidget=new QGroupBox;
  QHBoxLayout *stackedBottomWidgetLayout=new QHBoxLayout;
  stackedBottomWidgetLayout->addWidget(clearBottomTabWidgetButton);
  stackedBottomWidgetLayout->addWidget(bottomTabWidget);
  stackedBottomWidget->setLayout(stackedBottomWidgetLayout);
  bottomDockWidget->setWidget(stackedBottomWidget);

  addDockWidget(Qt::BottomDockWidgetArea, bottomDockWidget);

  setWindowIcon(QIcon(":/images/altair.png"));
  setWindowTitle("Interface  Altair"+ QString(VERSION));
}

void MainWindow::on_clearOutputTextButton_clicked()
{
    if (console->isVisible())
    {
        console->raise(); // to refocus if triggering main app button otherwise redundant
    }

    qobject_cast<QTextEdit*>(bottomTabWidget->currentWidget())->clear();
 }


void MainWindow::updateRecentFileActions()
{
QMutableStringListIterator i(recentFiles);

 while (i.hasNext())
 {
   if (!QFile::exists(i.next())) i.remove();
 }


 for (int j=0 ; j<MaxRecentFiles ; ++j)
 {
   if (j < recentFiles.count())
   {
     QString  text = tr("&%1 %2").arg(j+1).arg(strippedName(recentFiles[j]));
     recentFileActions[j]->setText(text);
     recentFileActions[j]->setData(QVariant(recentFiles[j]));
     recentFileActions[j]->setVisible(true);
   } else

   {
    recentFileActions[j]->setVisible(false);
   }

 }

 separatorAction->setVisible(!recentFiles.isEmpty());
}



QString MainWindow::strippedName(const QString &fullFileName)
{
  return QFileInfo(fullFileName).fileName();
}

void MainWindow::createMenus()
{
 fileMenu = menuBar()->addMenu("&Fichier");
 editMenu = menuBar()->addMenu("&Editer");
 processMenu = menuBar()->addMenu("&Lancer");
 optionsMenu = menuBar()->addMenu("&Configurer");
 aboutMenu = menuBar()->addMenu("&Aide");

 fileMenu->addAction(openAction);
 fileMenu->addAction(saveAction);
 fileMenu->addAction(saveAsAction);
 fileMenu->addAction(closeAction);

 separatorAction=fileMenu->addSeparator();
 for (int i=0; i<MaxRecentFiles ; ++i)
    fileMenu->addAction(recentFileActions[i]);
 fileMenu->addSeparator();
 fileMenu->addAction(exitAction);

 editMenu->addAction(displayAction);
 editMenu->addAction(displayOutputAction);
 editMenu->addAction(displayFileTreeViewAction);
 editMenu->addAction(displayManagerAction);
 editMenu->addAction(displayConsoleAction);
 editMenu->addAction(clearOutputTextAction);
 editMenu->addAction(editProjectAction);

 processMenu->addAction(burnAction);
 processMenu->addAction(encodeAction);


 optionsMenu->addAction(optionsAction);
 optionsMenu->addAction(configureAction);

 aboutMenu->addAction(helpAction);
 aboutMenu->addAction(aboutAction);
 aboutMenu->addAction(licenceAction);

}

void MainWindow::f()
{
    altair->updateProject(true);
}

void MainWindow::createActions()
{
  openAction = new QAction(tr("&Ouvrir le projet .alt"), this);
  openAction->setShortcut(QKeySequence("Ctrl+O"));
  openAction->setIcon(QIcon(":/images/project-open.png"));
  connect(openAction, SIGNAL(triggered()), altair, SLOT(on_openProjectButton_clicked()));

  saveAction = new QAction(tr("&Enregistrer"), this);
  saveAction->setShortcut(QKeySequence("Ctrl+S"));
  saveAction->setIcon(style()->standardIcon(QStyle::SP_DialogSaveButton));
  
  // Qt 5?3?2 onwards 
  connect(saveAction, &QAction::triggered, this, &MainWindow::f);
  
  //connect(saveAction, &QAction::triggered, [&] {altair->updateProject(true);});

  saveAsAction = new QAction(tr("En&registrer le projet comme..."), this);
  saveAsAction->setIcon(QIcon(":/images/document-save-as.png"));
  connect(saveAsAction, SIGNAL(triggered()), altair, SLOT(requestSaveProject()));

  closeAction = new QAction(tr("&Fermer le projet .alt"), this);
  closeAction->setShortcut(QKeySequence("Ctrl+W"));
  closeAction->setIcon(QIcon(":/images/document-close.png"));
  connect(closeAction, SIGNAL(triggered()), altair, SLOT(closeProject()));

  burnAction = new QAction(tr("&Lancer le décodage"), this);
  burnAction->setShortcut(QKeySequence("Ctrl+B"));
  burnAction->setIcon(QIcon(":/images/burn.png"));

  encodeAction = new QAction(tr("Créer le rapport"), this);
  encodeAction->setShortcut(QKeySequence("Ctrl+R"));
  encodeAction->setIcon(QIcon(":/images/encode.png"));
  connect(encodeAction, SIGNAL(triggered()), altair, SLOT(run()));

  optionsAction = new QAction(tr("&Options"), this);
  optionsAction->setShortcut(QKeySequence("Ctrl+P"));
  optionsAction->setIcon(QIcon(":/images/configure.png"));
  connect(optionsAction, SIGNAL(triggered()), this, SLOT(on_optionsButton_clicked()));

  configureAction= new QAction(tr("&Configurer l'interface"), this);
  configureAction->setIcon(QIcon(":/images/configure-toolbars.png"));
  connect(configureAction, SIGNAL(triggered()), this, SLOT(configure()));

  helpAction = new QAction(tr("&Aide"), this);
  helpAction->setShortcut(QKeySequence("Ctrl+H"));
  helpAction->setIcon(QIcon(":/images/help-contents.png"));
  connect(helpAction, SIGNAL(triggered()), altair, SLOT(on_helpButton_clicked()));

  displayAction = new QAction(tr("&Plein écran/Réduire"), this);
  displayAction->setIcon(QIcon(":/images/show-maximized.png"));
  connect(displayAction, SIGNAL(triggered()), this, SLOT(showMainWidget()));

  displayManagerAction = new QAction(tr("Ouvrir/Fermer le &gestionnaire de projet"), this);
  const QIcon iconViewList = QIcon(QString::fromUtf8( ":/images/manager.png"));
  displayManagerAction->setIcon(iconViewList);
  connect(displayManagerAction, SIGNAL(triggered()), this, SLOT(on_openManagerWidgetButton_clicked()));

  displayConsoleAction = new QAction(tr("Ouvrir/Fermer la console"), this);
  const QIcon consoleIcon = QIcon(QString::fromUtf8( ":/images/console.png"));
  displayConsoleAction->setIcon(consoleIcon);
  connect(displayConsoleAction, &QAction::triggered, [&] {console->on_displayConsoleButton_clicked(this);});

  editProjectAction=new QAction(tr("Editer le projet courant"), this);
  editProjectAction->setShortcut(QKeySequence("Ctrl+E"));
  editProjectAction->setIcon(QIcon(":/images/application-xml.png"));
  connect(editProjectAction, SIGNAL(triggered()), this, SLOT(on_editProjectButton_clicked()));

  displayOutputAction  = new QAction(tr("Ouvrir/Fermer les messages"), this);
  const QIcon displayOutput = QIcon(QString::fromUtf8( ":/images/display-output.png"));
  displayOutputAction->setIcon(displayOutput);
  connect(displayOutputAction, &QAction::triggered,  [this] {bottomDockWidget->setVisible(!bottomDockWidget->isVisible());});

  displayFileTreeViewAction  = new QAction(tr("Ouvrir/Fermer le gestionnaire de fichiers"), this);
  const QIcon displayFileTreeView = QIcon(QString::fromUtf8( ":/images/view-list-tree.png"));
  displayFileTreeViewAction->setIcon(displayFileTreeView);
  connect(displayFileTreeViewAction, SIGNAL(triggered()), this, SLOT(on_displayFileTreeViewButton_clicked()));
  
  clearOutputTextAction = new QAction(tr("Effacer le log"), this);
  const QIcon clearOutputText = QIcon(QString::fromUtf8( ":/images/edit-clear.png"));
  clearOutputTextAction->setIcon(clearOutputText);
  connect(clearOutputTextAction, &QAction::triggered,  [this] {on_clearOutputTextButton_clicked();});

  exitAction = new QAction(tr("&Quitter"), this);
  exitAction->setIcon(QIcon(":/images/application-exit.png"));
  exitAction->setShortcut(QKeySequence("Ctrl+Q"));
  connect(exitAction, &QAction::triggered,  [this] { exit(1);});

  aboutAction=new QAction(tr("&Au sujet de"), this);
  aboutAction->setIcon(QIcon(":/images/about.png"));

  connect(aboutAction, &QAction::triggered,  [this]  {
                                                          QUrl url=QUrl::fromLocalFile( altair->generateDatadirPath("/about.html") );
                                                          browser::showPage(url);
                                                      });

  licenceAction=new QAction(tr("Licence"), this);
  licenceAction->setIcon(QIcon(":/images/web/gplv3.png"));
  connect(licenceAction, &QAction::triggered,  [this]  {
                                                            QUrl url=QUrl::fromLocalFile( altair->generateDatadirPath("/licence.html") );
                                                            browser::showPage(url);
                                                        });

  for (int i=0; i < MaxRecentFiles ; i++)
  {
    recentFileActions[i] = new QAction(this);
    recentFileActions[i]->setVisible(false);
    connect(recentFileActions[i], SIGNAL(triggered()), altair, SLOT(openProjectFile()));
  }

  QAction* separator[6];
  for (int i=0; i < 6; i++)
    {
      separator[i] = new QAction(this) ;
      separator[i]->setSeparator(true);
    }

  actionList << openAction << saveAction << saveAsAction << closeAction << exitAction << separator[0] <<
                burnAction << encodeAction << displayOutputAction << displayFileTreeViewAction <<
                displayManagerAction << displayConsoleAction <<  separator[4] <<
                clearOutputTextAction <<  editProjectAction << separator[3] << configureAction <<
                optionsAction << helpAction << aboutAction ;
  
}

void MainWindow::configure()
{
     contentsWidget->setVisible(true);
}

void MainWindow::on_optionsButton_clicked()
{
  dialog->setVisible(!dialog->isVisible());
}

void MainWindow::on_displayFileTreeViewButton_clicked(bool isHidden)
{
   fileTreeViewDockWidget->setVisible(isHidden);
   altair->project[AUDIO]->importFromMainTree->setVisible(isHidden);

 }

void MainWindow::on_displayFileTreeViewButton_clicked()
{
    on_displayFileTreeViewButton_clicked(fileTreeViewDockWidget->isHidden());
}


void MainWindow::on_openManagerWidgetButton_clicked(bool isHidden)
{
   managerDockWidget->setVisible(isHidden);
 }

void MainWindow::on_openManagerWidgetButton_clicked()
{
    on_openManagerWidgetButton_clicked(managerDockWidget->isHidden());
}




void MainWindow::createToolBars()
{
 
 fileToolBar->addAction(openAction);
 fileToolBar->addAction(saveAction);
 fileToolBar->addAction(saveAsAction);
 fileToolBar->addAction(closeAction);
 fileToolBar->addAction(exitAction);
 fileToolBar->addSeparator();

 editToolBar->addAction(displayAction);
 editToolBar->addAction(displayOutputAction);
 editToolBar->addAction(displayFileTreeViewAction);
 editToolBar->addAction(displayManagerAction);
 editToolBar->addAction(displayConsoleAction);
 editToolBar->addAction(editProjectAction);

 processToolBar->addAction(burnAction);
 processToolBar->addAction(encodeAction);

 optionsToolBar->addAction(optionsAction);
 optionsToolBar->addAction(configureAction);

 aboutToolBar->addAction(helpAction);
 aboutToolBar->addAction(aboutAction);
}



void MainWindow::on_editProjectButton_clicked()
{

    if (altair->projectName.isEmpty()) return;
    editWidget = new QMainWindow(this);
    editWidget->setWindowTitle(tr("Edition du projet ")+altair->projectName.left(8)+"..."+altair->projectName.right(12));
    QMenu *fileMenu = new QMenu(tr("&Fichier"), this);
    editWidget->menuBar()->addMenu(fileMenu);

     const char* keys[]={"Nouveau", "Ouvrir", "Enregistrer", "Enregistrer comme...", "Actualiser", "Enregistrer et quitter", "Quitter"};
     const char* seq[]={"Ctrl+N","Ctrl+O","Ctrl+S","Ctrl+T","Ctrl+R","Ctrl+E","Ctrl+Q"};
     int j=0;

    for (const char* k:  keys)
    {
        actionHash[k]=new QAction(tr(k), this);
        fileMenu->addAction(actionHash[k]);
        actionHash[k]->setShortcut(QKeySequence(seq[j++]));
    }

    QFont font;
    font.setFamily("Courier");
    font.setFixedPitch(true);
    font.setPointSize(10);

    editor = new QTextEdit;
    editor->setFont(font);

    highlighter = new Highlighter(editor->document());

    if (altair->projectName.isEmpty()) return;
   QFile  *file=new QFile(altair->projectName);

   if (file->open(QFile::ReadWrite| QFile::Text))
   {
       editor->setPlainText(file->readAll());
       file->close();
   }
   // do not capture file by reference!
   connect(actionHash["Nouveau"],
                 &QAction::triggered,
                 [this] { editor->clear();});

   connect(actionHash["Ouvrir"],
                 &QAction::triggered,
                 [file, this]
                                  {
                                     file->~QFile();
                                     altair->on_openProjectButton_clicked() ;
                                     editWidget->~QMainWindow();
                                     on_editProjectButton_clicked();
                                   });

   connect(actionHash["Enregistrer"],
                 &QAction::triggered,
                 [file, this]
                                 {
                                    file->open(QFile::Truncate |QFile::WriteOnly| QFile::Text);
                                    file->write(editor->document()->toPlainText().toUtf8()) ;
                                    file->close();
                                    Altair::RefreshFlag = Altair::RefreshFlag |UpdateTree | ParseXml;
                                    altair->initializeProject(true);
                                  });

   connect(actionHash["Enregistrer comme..."],
                  &QAction::triggered,
                  [file, this] {saveProjectAs(file);});

   connect(actionHash["Actualiser"],
                 &QAction::triggered,
                 [file, this]
                                 {
                                    altair->updateProject(true);
                                    if (file->open(QFile::ReadWrite |  QFile::Text))
                                       {
                                           editor->clear();
                                           editor->setPlainText(file->readAll());
                                           file->close();
                                       }
                                  });

   connect(actionHash["Enregistrer et quitter"],
                  &QAction::triggered,
                 [this]
                         {
                            actionHash["Enregistrer"]->trigger();
                            actionHash["Quitter"]->trigger();
                         });

   connect(actionHash["Quitter"],
                 &QAction::triggered,
                 [file, this]
                                  {
                                     file->~QFile();
                                     editWidget->~QMainWindow() ;
                                   });
   editWidget->setCentralWidget(editor);
   editWidget->setGeometry(200,200,600,800);
   editWidget->show();

}


void MainWindow::saveProjectAs(QFile* file)
{
    QString newstr=QFileDialog::getSaveFileName(this, tr("Enregistrer le projet comme..."), QDir::currentPath(), tr("projet altair (*.alt)"));
    if (newstr.isEmpty()) return;
    if (newstr == altair->projectName)
    {
        actionHash["Enregistrer"]->trigger();
        return;
    }

    if  (QFileInfo(newstr).isFile())
    {
          if (QMessageBox::No == QMessageBox::warning(this, tr("Ecraser le fichier ?"), tr("Ce fichier va être écrasé.\nAppuyer sur Oui pour confirmer, non pour quitter."), QMessageBox::Yes|QMessageBox::No))
             return;
          else
          {
                 QFile newfile(newstr);
                 newfile.remove();
          }
    }
    if (file->rename(newstr) ==false) return;
    altair->projectName=newstr;
    if (file->open(QFile::WriteOnly | QFile::Truncate | QFile::Text))
    {
       file->write(editor->document()->toPlainText().toUtf8()) ;
    }
    file->close();
    Altair::RefreshFlag = Altair::RefreshFlag |UpdateTree | ParseXml;
    altair->initializeProject(true);
}

void MainWindow::configureOptions()
{
    /* plain old data types must be 0-initialised even though the class instance was new-initialised. */

    contentsWidget = new QDialog(this);
    contentsWidget->setVisible(false);

    QGroupBox *displayGroupBox =new QGroupBox(tr("Affichage"));
    QGroupBox *displayToolBarsGroupBox =new QGroupBox(tr("Barres d'outils"));

    closeButton = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);

    QGridLayout *layout=new QGridLayout;
    QVBoxLayout *displayDocksLayout=new QVBoxLayout;
    QVBoxLayout *displayToolBarsLayout=new QVBoxLayout;
    QVBoxLayout *behaviourLayout=new QVBoxLayout;

    defaultFileManagerWidgetLayoutBox=new FCheckBox("Afficher le gestionnaire de fichiers",
                                                                            flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                            "fileManagerDisplay",
                                                                           {"Interface", "Afficher le gestionnaire de fichiers"});

    defaultProjectManagerWidgetLayoutBox=new FCheckBox("Afficher le gestionnaire de projet",
                                                                            flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                            "projectManagerDisplay",
                                                                            {"Interface", "Afficher le gestionnaire de projet"});

    defaultConsoleLayoutBox=new FCheckBox("Afficher la console",
                                                                            flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                            "launchConsoleAsTab",
                                                                            {"Interface", "Ajouter un onglet pour la console/Supprimer la console"});

    defaultFullScreenLayout=new FCheckBox("Plein écran",
                                                        flags::status::enabledUnchecked|flags::commandLineType::noCommandLine,
                                                        "fullScreenDisplay",
                                                        {"Interface", "Plein écran au lancement"});


    

    defaultOutputTextEditBox=new FCheckBox("Afficher les messages",
                                                                   flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                   "outputTextEdit",
                                                                   {"Interface", "Afficher les messages"});
    
    defaultFileToolBarBox=new FCheckBox("Afficher la barre d'outils de fichiers",
                                                                flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                "fileToolBar",
                                                                {"Interface", "Afficher la barre d'outils de fichiers"});
    
    defaultEditToolBarBox=new FCheckBox("Afficher la barre d'outils d'édition",
                                                                flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                "editToolBar",
                                                                {"Interface", "Display Edit toolBar"});
    
    defaultProcessToolBarBox=new FCheckBox("Afficher la barre d'outils de processus",
                                                                flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                "processToolBar",
                                                                {"Interface", "Afficher la barre d'outils de processus"});
    
    defaultOptionsToolBarBox=new FCheckBox("Afficher la barre d'options",
                                                                flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                "optionsToolBar",
                                                                {"Interface", "Afficher les options"});
    
    defaultAboutToolBarBox=new FCheckBox("Afficher la barre d'A propos",
                                                                flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                "aboutToolBar",
                                                                {"Interface", "Afficher la barre A propos"});
    
    QGroupBox* behaviorGroupBox =new QGroupBox(tr("Sauvegarder/Lancer"));

    defaultSaveProjectBehavior=new FCheckBox("Sauvegarder le projet .alt automatiquement",
                                                                               flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                               "saveProjectBehavior",
                                                                               {"Interface", "Sauvegarder le projet .alt automatiquement"});

    defaultLoadProjectBehavior=new FCheckBox("Charger le projet .alt au lancement",
                                                                            flags::status::enabledChecked|flags::commandLineType::noCommandLine,
                                                                            "loadProjectBehavior",
                                                                            {"Interface", "Charger le projet .alt au lancement"});

    displayWidgetList  <<  defaultFileManagerWidgetLayoutBox
                       << defaultProjectManagerWidgetLayoutBox
                       << defaultConsoleLayoutBox
                       << defaultOutputTextEditBox
                       << defaultFullScreenLayout;


    behaviorWidgetList   << defaultSaveProjectBehavior
                             << defaultLoadProjectBehavior;
    
    displayToolBarCBoxList <<  defaultFileToolBarBox
                       <<  defaultEditToolBarBox
                       <<  defaultProcessToolBarBox
                       <<  defaultOptionsToolBarBox
                       <<  defaultAboutToolBarBox;
    
    QList<QToolBar*> displayToolBarList ;
    
#define buildToolBar(bar, text) \
  bar = addToolBar(tr(text));\
  bar->setVisible(false);\
  bar->setIconSize(QSize(48,48)); 
      
    buildToolBar(fileToolBar, "&File") 
    buildToolBar(editToolBar, "&Edit") 
    buildToolBar(processToolBar, "&Process")
    buildToolBar(optionsToolBar, "&Data") 
    buildToolBar(aboutToolBar, "&Help")          
    
    displayToolBarList <<  fileToolBar
                       << editToolBar 
                       << processToolBar
                       << optionsToolBar 
                       << aboutToolBar;                                  

    for (FCheckBox* a : displayWidgetList)    displayDocksLayout->addWidget(a);
    for (FCheckBox* a : behaviorWidgetList)   behaviourLayout->addWidget(a);
    for (int i=0; i< displayToolBarList.size(); i++)
    {
        displayToolBarsLayout->addWidget(displayToolBarCBoxList[i]);
        connect(displayToolBarCBoxList[i], SIGNAL(toggled(bool)), displayToolBarList[i], SLOT(setVisible(bool)));
    }
 
    displayGroupBox->setLayout(displayDocksLayout);
    behaviorGroupBox->setLayout(behaviourLayout);
    displayToolBarsGroupBox->setLayout(displayToolBarsLayout);
    layout->addWidget(displayGroupBox, 0,0);
    layout->addWidget(behaviorGroupBox, 1, 0);
    layout->addWidget(displayToolBarsGroupBox, 0, 1);
    layout->addWidget(closeButton, 2, 0);
    contentsWidget->setLayout(layout);
    
    connect(closeButton, &QDialogButtonBox::accepted,
                        [this]  {
                                    for (FCheckBox* a : displayWidgetList + behaviorWidgetList + displayToolBarCBoxList)
                                        settings->setValue(a->getHashKey(), a->isChecked());
                                
                                    if (    (defaultSaveProjectBehavior->isChecked())
                                         || (QMessageBox::Yes == QMessageBox::warning(this,
                                                                                      tr("Sauvegarder le projet"),
                                                                                      tr("Le projet n'a pas été sauvegardé.\nAppuyer sur Oui pour le sauvegarder\nou sur Non pour fermer le dialogue sans sauvegarder le projet."),
                                                                                      QMessageBox::Yes|QMessageBox::No))
                                        )
                                        altair->updateProject();
                                         
                                    contentsWidget->accept();
                                });

    /* note on connection syntax
     * Here the new Qt5 connection syntax should be used with care and disregarded when both an action button and an FCheckBox activate a slot as the slots
     * are overloaded (which could possibly be rewritten) and a) the action button uses the argumentless slot whilst
     * b) the boolean version of slots must be used by the FcheckBox. The new Qt5 syntax cannot work this out as it does not manage overloading. */

    connect(closeButton, &QDialogButtonBox::rejected, contentsWidget, &QDialog::reject);
    
    connect(defaultFileManagerWidgetLayoutBox, SIGNAL(toggled(bool)), this, SLOT(on_displayFileTreeViewButton_clicked(bool)));
    connect(defaultProjectManagerWidgetLayoutBox, SIGNAL(toggled(bool)), this, SLOT(on_openManagerWidgetButton_clicked(bool)));
    
    connect(defaultConsoleLayoutBox, &FCheckBox::toggled, [this] {console->detachConsole(defaultConsoleLayoutBox->isChecked(), this);});
    connect(defaultFullScreenLayout, SIGNAL(toggled(bool)), this, SLOT(showMainWidget(bool)));
    connect(defaultOutputTextEditBox, &FCheckBox::toggled, [this] {bottomDockWidget->setVisible(defaultOutputTextEditBox->isChecked());});
    connect(defaultLoadProjectBehavior, &FCheckBox::toggled, [this] {if (defaultLoadProjectBehavior->isChecked()) altair->RefreshFlag |=  ParseXml;});

    setWindowTitle(tr("Configuration"));
    setWindowIcon(QIcon(":/images/altair.png"));
}


void MainWindow::showMainWidget(bool full)
{
  if (full)
  {
      setWindowState(Qt::WindowFullScreen);
      displayAction->setIcon(QIcon(":/images/show-normal.png"));
  }
  else
  {
      setWindowState(Qt::WindowNoState);
      displayAction->setIcon(QIcon(":/images/show-maximized.png"));
  }

}

void MainWindow::showMainWidget()
{
      showMainWidget(this->windowState() != Qt::WindowFullScreen);
}


static bool flushHtmlContent=true;

void MainWindow::feedConsoleWithHtml()
{
#ifdef DEBUG
    static qint64 tableFlag=0;
    QFile testInput(QDir::homePath()+"/input"+QString::number(tableFlag));
    QFile testOutput(QDir::homePath()+"/output"+QString::number(tableFlag));

    testInput.open(QFile::WriteOnly|QFile::Truncate);
    testOutput.open(QFile::WriteOnly|QFile::Truncate);
    QTextStream input(&testInput);
    QTextStream output(&testOutput);
#endif

    QString  readData;

    /* Owing to experimentally verified occurrences of altair-author process std output interruptions
     * whilst just creating the Html code for a console table, resulting in display issues, it is necessary to integrate a 'delayed display'
     * cut-and-paste capability so as to ensure corresponding <table>...</table> tags in the same file */

    QRegExp reg("(\\[INF\\]|\\[PAR\\]|\\[MSG\\]|\\[ERR\\]|\\[WAR\\]|\\[LICENSE\\]|\\[DBG\\])([^\n]+)");
 

     if (altair->outputType == "DVD-Audio authoring")
     {
            while (altair->process.canReadLine())
            {
                QString buffer=altair->process.readLine();

                /* must come first before block (2) */


                /* block (2) */


                if (buffer.contains(reg))
                {

                    switch (reg.cap(1).at(1).toLatin1())
                    {
                    case 'I' :
                        buffer= buffer.replace(reg, (QString)PROCESSING_HTML_TAG "\\2"); break;
                    case 'P' :
                        buffer=buffer.replace(reg, (QString)  PARAMETER_HTML_TAG "\\2"); break;
                    case 'M' :
                        buffer=buffer.replace(reg, (QString) STATE_HTML_TAG "\\2"); break;
                    case 'E' :
                        buffer=buffer.replace(reg, (QString) ERROR_HTML_TAG "\\2"); break;
                    case 'W' :
                        buffer=buffer.replace(reg, (QString) WARNING_HTML_TAG "\\2"); break;
                    case 'L' :
                        buffer=buffer.replace(reg, (QString)  LICENSE_HTML_TAG "\\2"); break;
                    case 'D' :
                        buffer=buffer.replace(reg, (QString)  DBG_HTML_TAG "\\2"); break;

                    }

                }

                if (flushHtmlContent)
                {
                    if (!readData.isEmpty())
                    {
                        consoleDialog->insertHtml(readData.replace("\n","<br>" ));
                       output << readData ;
                       readData.clear();
                    }
                    else
                    {
                        consoleDialog->insertHtml(buffer.replace("\n", "<br>"));
                        output << buffer;
                    }
                }
            }

    }

   consoleDialog->insertHtml(readData.replace("\n","<br>" ));
   consoleDialog->moveCursor(QTextCursor::End);

#ifdef DEBUG

    testInput.close(); testOutput.close();
    tableFlag++;
#endif

}

void MainWindow::feedConsole()
{

        consoleDialog->insertHtml(QString("<br>" PROCESSING_HTML_TAG " ") +altair->outputType+"...<br>");
        consoleDialog->moveCursor(QTextCursor::End);
        console->appendHtml(QString("<br>" PROCESSING_HTML_TAG " " ) +altair->outputType+"...<br>");

        connect(&(altair->process), &QProcess::readyReadStandardOutput, [&] {
                feedConsoleWithHtml();
            });

 }

