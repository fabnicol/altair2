{
    "collab_server" : "",
    "contents" : "##\n#  Fonctions auxiliaires\n##\n\n\n\nchemin <-  function(fichier)\n  file.path(chemin.dossier.données, fichier)\n\nfile2utf8 <- function(nom, encodage.in = encodage.entrée)  {\n  \n chem <- chemin(nom)\n err <- system2(iconv, c(\"-f\", encodage.in, \"-t\", \"UTF-8\", shQuote(chem), \"-o\", \"temp\"))\n if (! err)  err <- system2(\"mv\", c(\"temp\", shQuote(chem))) else stop(\"Erreur d'encodage avec iconv\")\n if (! err)  message(\"Conversion réussie\") else stop(\"Erreur de copie fichier après encodage avec iconv\")\n}\n\n#obsolète\n# en.séparateurs <- function(chem)  {\n# \n#   commande <- sed %+% \" -e s/,/\\\\./g -e s/;/,/g -i \" %+% shQuote(chem)\n#   shell(commande)\n# }\n\n# fr.séparateurs <- function(chem)  {\n#   \n#   commande <- sed %+% \" -e s/,/;/g -e s/\\\\./,/g -i \" %+% shQuote(chem)\n#   shell(commande)\n# }\n\n\n# Trouve le numéro de la ligne à laquelle se situe la liste des noms de variables\n# en recherchant soit le mot \"Matricule\" soit une expression du type \"Code...\"\n# Il faudra déduire ce \"skip\" du read.csv pour récupérer proprement les noms de variable\n\n# Pour cela on scanne les 25 premières lignes de la table une première fois\n\n\ntrouver.valeur.skip <-  function(chemin.table, encodage, classes = NA, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée)\n  max(\n    sapply(\n      read.csv(chemin.table, sep=séparateur.liste, dec=séparateur.décimal, nrows = 25, fileEncoding = encodage.entrée, colClasses = classes),\n      function(x)\n      {\n        m <- match(champ.détection.1, x, nomatch = 0 )\n        if (m == 0)\n          m <- pmatch(champ.détection.2, x, nomatch = 0, duplicates.ok = FALSE )\n        return(m)\n      }\n    ))\n\n\n# selectionner.cle.matricule <-  function(Base1, Base2)\n# {\n#   if (fusionner.nom.prénom) {\n#      subset(Base1,\n#            select = c(\"Nom\", \"Prénom\", étiquette.matricule, setdiff(names(Base1),names(Base2))))\n#     } else {\n#      subset(Base1,\n#          select = c(étiquette.matricule, setdiff(names(Base1), names(Base2))))\n#     }\n# }\n\nsélectionner.clé <-  function(base1, base2)\n{\n  Base1 <- get(base1)\n  Base2 <- get(base2)\n\n  if (fusionner.nom.prénom) {\n\n    Set1 <- c(\"Mois\", \"Année\", étiquette.matricule, setdiff(names(Base1), names(Base2)))\n    Set2 <- setdiff(names(Base2), c(\"Nom\", \"Prénom\", étiquette.matricule))\n\n    assign(base1,\n           subset(Base1, select = c(\"Nom\", \"Prénom\", Set1)),\n           envir = .GlobalEnv)\n\n    assign(base1,\n           cbind(as.data.frame(convertir.nom.prénom.majuscules(Base1[, c(\"Nom\", \"Prénom\")])),\n                 Base1[, Set1]),\n           envir = .GlobalEnv)\n\n    assign(base2,\n           cbind(as.data.frame(convertir.nom.prénom.majuscules(Base2[, c(\"Nom\", \"Prénom\")])),\n                 Base2[, Set2]),\n           envir = .GlobalEnv)\n\n\n\n  } else {\n\n    assign(base1, subset(Base1,\n                         select = c(étiquette.matricule,\"Mois\",\"Année\",\n                         setdiff(names(Base1), names(Base2)))), envir = .GlobalEnv)\n\n  }\n}\n\n\n\nread.csv.skip <- function(x, encodage = encodage.entrée, classes = NA, étiquettes = NULL, drop = NULL,\n                          rapide = FALSE, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée,\n                          convertir.encodage = TRUE)\n{\n  chem <- chemin(x)\n  if (! rapide) {\n\n    T <- read.csv(chem,\n                   comment.char = \"\",\n                   sep = séparateur.liste,\n                   dec = séparateur.décimal,\n                   colClasses = classes,\n                   skip = trouver.valeur.skip(chem, encodage, séparateur.liste = séparateur.liste, séparateur.décimal = séparateur.décimal),\n                   encoding = encodage)\n\n    if (!is.null(drop)) { T <- T[-(drop)] }\n\n  } else {\n    \n    if (encodage != \"UTF-8\" && convertir.encodage) {\n      message(\"La table en entrée doit être encodée en UTF-8\")\n      if (convertir.encodage) message(\"Conversion via iconv du format \" %+% encodage %+% \" au format UTF-8...\") else stop(\"Arrêt : convertir l'encodage de la table en UTF-8.\")\n      file2utf8(x, encodage.in = encodage)\n    }\n      \n    # data.table n'admet d'argument dec qu'à partir de la version 1.9.5 \n    \n    if (is.na(classes)) classes = NULL\n    \n    T <- try(data.table::fread(chem,\n                      sep = séparateur.liste,\n                      dec = séparateur.décimal,\n                      header = TRUE,\n                      skip = champ.détection.1,\n                      colClasses = classes,\n                      encoding = ifelse(setOSWindows, \"Latin-1\", \"UTF-8\"),\n                      showProgress = FALSE))\n\n\n  }\n\nif (!is.null(étiquettes)) names(T) <- étiquettes\n\n\nreturn(T)\n}\n\nSauv.base <- function(chemin.dossier, nom, nom.sauv, encodage = encodage.sortie, sep = séparateur.liste.sortie, dec = séparateur.décimal.sortie)\n{\n  message(\"Sauvegarde de \", nom.sauv)\n  write.table(get(nom),\n             paste0(chemin.dossier, \"/\", nom.sauv, \".csv\"), \n             quote = FALSE,\n             sep = sep,\n             dec = dec,\n             row.names = FALSE,\n             fileEncoding = if (setOSWindows) encodage else \"UTF-8\")\n}\n\nsauv.bases <- function(dossier, ...)\n{\n  if (! dir.exists(dossier))\n  {\n    stop(\"Pas de dossier de travail spécifié\")\n  }\n\n  tmp <- as.list(match.call())\n  tmp[1] <- NULL\n\n  message(\"Dans le dossier \", dossier,\" :\")\n  invisible(lapply(tmp[-1], function(x) if (exists(x)) Sauv.base(dossier, x, x)))\n}\n\n# Utiliser une assignation globale\n# car la fonction anonyme ne comporte que de variables locales\n\nRead.csv <- function(base.string, vect.chemin, charger = charger.bases, colClasses = NA, colNames = NULL,\n                     drop = NULL, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée,\n                     rapide = FALSE, convertir.encodage = TRUE, encodage = encodage.entrée)  {\n\n    if (charger.bases) {\n\n        assign(base.string,\n               do.call(rbind, lapply(vect.chemin,\n                                     read.csv.skip,\n                                        classes = colClasses,\n                                        étiquettes = colNames,\n                                        séparateur.liste = séparateur.liste,\n                                        séparateur.décimal = séparateur.décimal,\n                                        drop = drop,\n                                        convertir.encodage = convertir.encodage,\n                                        encodage = encodage,\n                                        rapide = rapide)),\n               envir = .GlobalEnv)\n    }\n}\n\n\nRésumé <- function(x,y, align = 'r', extra = 0, type = \"pond\")  {\n    \n      Y <- na.omit(y)\n \n      \n      if (! is.list(Y) || is.data.frame(Y)) {\n\n        if (type == \"pond\") {\n          T <- sapply(Y, function(x) {\n            q <- bigvis::weighted.quantile(x, Y$quotité.moyenne, na.rm = TRUE) \n            q <- append(q, weighted.mean(x, Y$quotité.moyenne, na.rm = TRUE), 3)\n            prettyNum(q, big.mark = \" \", digits = 2)\n          })\n          \n          S <- cbind(c(\"Minimum\", \"1er quartile\", \"Médiane\", \"Moyenne\", \"3ème quartile\", \"Maximum\"), T)\n          \n        } else if (type == \"standard\") {\n          S <- cbind(c(\"Minimum\", \"1er quartile\", \"Médiane\", \"Moyenne\", \"3ème quartile\", \"Maximum\"),\n                     sapply(Y, function(x) prettyNum(summary(x), big.mark = \" \")))\n        }\n        \n        \n        if (! missing(extra)) {\n          if (extra == \"length\") {\n\n             S <- cbind(S, c(\"\", \"\", \"\", ifelse(is.vector(Y), length(Y), nrow(Y)), \"\", \"\"))\n   \n          } else {    \n            \n            if (is.numeric(extra))\n              S <- cbind(S, c(\"\", \"\", \"\", as.character(extra), \"\", \"\"))\n          }\n       }\n               \n      } else {\n\n        if (type == \"pond\") {\n          S <- cbind(c(\"Minimum\", \"1er quartile\", \"Médiane\", \"Moyenne\", \"3ème quartile\", \"Maximum\"),\n                     sapply(Y, function(x) {\n                                 q <- bigvis::weighted.quantile(x[[1]],\n                                                   floor(x[[2]] * 1000), na.rm = TRUE)\n                                 \n                                 q <- append(q, weighted.mean(x[[1]], x[[2]], na.rm = TRUE), 3)\n                               \n                                 prettyNum(q, big.mark = \" \")\n                       }))\n        } else if (type == \"standard\") {\n          S <- cbind(c(\"Minimum\", \"1er quartile\", \"Médiane\", \"Moyenne\", \"3ème quartile\", \"Maximum\"),\n                     sapply(Y, function(x) prettyNum(summary(x), big.mark = \" \")))\n        }\n        \n        if (! missing(extra) && extra == \"length\") {\n          \n           n <- ncol(S) - 1  \n           temp <- S[ , 1]\n          \n           for (i in 1:n) {\n               temp <- cbind(temp, S[ , i + 1])\n\n               temp <- cbind(temp, c(\"\", \"\", \"\", ifelse(is.vector(Y[[i]]), length(Y[[i]]), nrow(Y[[i]])), \"\", \"\"))\n               \n\n           }\n           # S est de type matrix\n           \n           S <- temp\n        }\n      }\n\n \n     dimnames(S)[[2]] <- c(\"Statistique\", x)\n\n     kable(S, row.names = FALSE, align = align, booktabs = TRUE)\n\n}\n\nTableau <- function(x, ...)\n{\n  V <- c(...)\n  if (\"sep.milliers\" %in% names(V))\n  {\n    sep.milliers <- V[\"sep.milliers\"]\n    V$sep.milliers <- NULL\n  }  else\n  sep.milliers <- \" \"\n\n  T <- t(prettyNum(V, big.mark = sep.milliers))\n  T <- as.data.frame(T)\n  names(T) <- x\n  kable(T, row.names = FALSE, align = \"c\", booktabs= TRUE)\n}\n\nTableau.vertical <- function(colnames, rownames, extra = \"\", ...)\n{\n    tmp <- c(...)\n   \n    if (! all(lapply(tmp, is.function))) {\n      message(\"all arguments must be functions\")\n      return(\"\")\n    }\n    \n    lr <- length(rownames)\n    \n    h <- function(x) as.numeric(sub(\",\",\".\", sub(\" \", \"\", x, fixed=T), fixed=T))\n    \n    g <- function(f) {\n        S <- rep(\"\", lr)\n    \n        S[ceiling(lr/2)] <- as.character(prettyNum((h(f(rownames[lr]))/h(f(rownames[1])) - 1) * 100, digits = 3))\n    \n        S\n    }\n      \n  \n    if (! missing(extra) && (is.character(extra)) && (extra == \"variation\")) {\n      T <- data.frame(rownames)\n      NT <- colnames[1]\n      ltmp <- length(tmp)\n      for (x in seq_len(ltmp)) {\n        T <- cbind(T, sapply(rownames, tmp[[x]]), g(tmp[[x]]))\n        NT <- c(NT, colnames[[x + 1]], \"Variation (%)\")\n      }\n    \n      names(T) <- NT\n    } else {\n      T <- data.frame(rownames, lapply(tmp, function(f) sapply(rownames, f)))\n      names(T) <- colnames\n    }\n    \n    kable(T, row.names = FALSE, align = \"c\", booktabs= TRUE)\n}\n\nTableau.vertical2 <- function(colnames, rownames, ...)\n{\n  tmp <- list(...)\n  \n  T <- data.frame(rownames, \n                  lapply(tmp, function(y) formatC(y, \n                                                          big.mark=\" \",\n                                                          width=\"12\",\n                                                          format=\"f\",\n                                                          digits=1,\n                                                          decimal.mark=\",\",\n                                                          preserve.width=\"common\")))\n  names(T) <- colnames\n\n  kable(T, row.names = FALSE, align = NULL, booktabs= TRUE)\n}\n\n\n\nv.jmois  <-  c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\nv.jmois.leap  <-  c(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\ncalcul.nb.jours.mois <- function(Mois, année)   if ((année - 2008) %%4 == 0) {\n    return(sum(v.jmois.leap[Mois])) \n    } else {\n    return(sum(v.jmois[Mois]))\n  }\n    \n\npositive <- function(X) X[!is.na(X) & X > 0]\nnon.null <- function(X) X[!is.na(X) & X != 0]\nsignificatif <- function(x) !is.na(x) & abs(x) > 0.01\n\ninstaller.paquet <- function(paquet, rigoureusement = FALSE)\n{\n  if (missing(paquet))  return(NA_character_)\n  Paquet <- deparse(paquet)\n  if (length(find.package(Paquet, quiet = TRUE)) == 0)\n  {\n    install.packages(Paquet)\n    if (length(find.package(Paquet, quiet = TRUE)) !=0 )\n    {\n      message(Paquet, \" a été installé.\")\n      return(invisible(1))\n    }\n    else\n    {\n      message(Paquet, \" n'a pas été installé.\")\n      if (rigoureusement == TRUE)\n      {\n        message(\"Arrêt: le paquet \", Paquet, \" n'a pas pu être installé.\")\n        stop(\"Fin\")\n      }\n      return(invisible(0))\n    }\n  }\n  else\n    message(Paquet, \" est déjà installé.\")\n  return(invisible(0))\n}\n\ninstaller.paquets <- function(..., rigoureusement = FALSE)\n{\n  tmp <- as.list(match.call())\n  tmp[1] <- NULL\n  if (!missing(rigoureusement)) tmp[length(tmp)] <- NULL\n  if (length(tmp) == 0) return(0)\n\n  invisible(do.call(sum, lapply(tmp, function(x) installer.paquet(x, rigoureusement))))\n}\n\nconvertir.nom.prénom.majuscules <- function(S)\n{\n\n  S[ , c(\"Nom\", \"Prénom\")] <- apply(S[ , c(\"Nom\", \"Prénom\")],\n                                    2,\n                                    function(x)\n                                      toupper(chartr(\"éèôâçë\",\"eeoaice\", x)))\n\n\n}\n\n#Age fin décembre de l'Année en années révolues si né au XXème siècle\n# On trouve quelques valeurs aberrantes correspondant à des NIr non conventionnels par ex 8041620130028\nextraire.nir <- function(Base, An)  {\n  Base[ , `:=`(age = An - (as.numeric(substr(Nir, 2, 3)) + 1900),\n               sexe = substr(Nir, 1, 1))]\n  \n  \n  temp <- Base[age < 69 & age > 14 & (sexe == \"1\" | sexe == \"2\")]\n\n  H <- temp[sexe == \"1\",  .(Hommes = .N), by = \"age\"]\n  F <- temp[sexe == \"2\",  .(Femmes = .N), by = \"age\"]\n  \n  HF <- merge(\n          merge(H, F, by = \"age\", all = TRUE), \n          data.table(age = 15:68),\n          by = \"age\",\n          all = TRUE)\n  \n  HF[ , total := sum(Hommes, Femmes, na.rm = TRUE), by = \"age\"]\n  \n}\n\n\n# tester.homogeneite.matricules(Base)\n\n#  Teste si, dans une base, la proportion d'enregistrements Noms-Prénoms dont les matricules ne sont pas identiques\n#  reste inférieure à une marge de tolérance fixée (taux.tolérance.homonymie)\n#  utilité : tester si l'appariement sur Nom-Prénom au lieu de matricule sera acceptable\n\ntester.homogeneite.matricules <- function(Base) {\n\n  message(\"Contrôle sur la cohérence de l'association Nom-Prénom-Matricule (homonymies et changements de matricule)\")\n  S <- convertir.nom.prénom.majuscules(Base[ , c(\"Nom\", \"Prénom\", \"Matricule\")])\n\n  with.matr    <-   nrow(unique(S))\n  without.matr <-   nrow(unique(S[ , c(\"Nom\", \"Prénom\")]))\n\n  message(\"Matricules distincts: \", with.matr)\n  message(\"Noms-Prénoms distincs: \", without.matr)\n\n  if (with.matr  >   (1 + taux.tolérance.homonymie/100) * without.matr)\n  {\n     message(paste0(\"Résultats trop différents (\", taux.tolérance.homonymie, \" % de marge tolérée). Changement de régime de matricule.\"))\n     if (fusionner.nom.prénom == FALSE)\n       stop(\"Vous pouvez essayer de fusionner sur Nom, Prénom en spécifiant fusionner.nom.prénom <- TRUE dans prologue.R\", call. = FALSE)\n  }\n}\n\nlongueur.non.na <- function(v) if (is.vector(v)) length(v[!is.na(v)]) else if (is.data.frame(v)) nrow(na.omit(v))\n\n# opérateurs infixe\n\n# concaténer deux strings\n\n`%+%` <- function(x, y) paste0(x,  y)\n\n`%*%` <- function(x, y) if (is.na(x) | is.na(y)) return(0) else return(x*y)\n\n# saut de page\n\nnewpage <- function() {\n  if (PDF == TRUE) {\n  cat(\"\\n\\\\newpage\\n\")\n  } else {\n  cat(\"<p style=\\\"page-break-after:always;\\\"></p>\")\n  }\n}\n\n# numérotation des tableaux\n\nnuméro.tableau <- 0\n\nincrément <- function() { \n  numéro.tableau <<- numéro.tableau + 1 \n  numéro.tableau\n}\n\nchapitre <- 0\n\nincrémenter.chapitre <- function() {\n  chapitre <<- chapitre + 1\n  invisible(chapitre)\n}\n\nFR <- function(x) formatC(x, big.mark = \" \")\n\npyramidf <- function(data, Laxis=NULL, Raxis=NULL,\n                     frame=c(-1.15, 1.15, -0.05, 1.1),\n                     AxisFM=\"d\", AxisBM=\"\", AxisBI=3, Cgap=0.3, Cstep=5, Csize=1, \n                     Llab=\"Hommes\", Rlab=\"Femmes\", Clab=\"Âges\", GL=TRUE, Cadj=-0.03, \n                     Lcol=\"cadetblue1\", Rcol=\"thistle1\", Ldens=-1, Rdens=-1, main=\"\",\n                     linewidth=2, ...) {\n  # frame version, added since rev. 1.4, 4th September 2014.\n  # (C) Minato Nakazawa <minato-nakazawa@umin.net>\n  Left <- data[,Hommes]\n  \n  Right <- data[,Femmes]\n  \n  if (ncol(data)==2) { Center <- row.names(data) } else { Center <- data[,age] }\n  if (is.null(Laxis)) { Laxis <- seq(0,ceiling(max(c(Left,Right), na.rm=TRUE)/10)*10,len=5) }\n  if (is.null(Raxis)) { Raxis <- Laxis }\n  # setting x-y axes\n  BX <- c(-1-Cgap/2,1+Cgap/2)\n  BY <- c(-0.05,1.1)\n  XC <- function(XB) { (XB-BX[1])*(frame[2]-frame[1])/(2+Cgap)+frame[1] }\n  YC <- function(YB) { (YB-BY[1])*(frame[4]-frame[3])/1.15+frame[3] }\n  # scaling factors\n  LL <- max(Laxis)\n  LR <- min(Laxis)\n  LS <- LL-LR\n  LI <- length(Laxis)\n  RL <- min(Raxis)\n  RR <- max(Raxis)\n  RS <- RR-RL\n  RI <- length(Raxis)\n  # ticks of axis\n  segments(XC(-(Laxis-LR)/LS-Cgap/2),YC(-0.01),XC(-(Laxis-LR)/LS-Cgap/2),YC(0.01))\n  segments(XC((Raxis-RL)/RS+Cgap/2),YC(-0.01),XC((Raxis-RL)/RS+Cgap/2),YC(0.01))\n  # vertical grid lines\n  if (GL) {\n    segments(XC(-(Laxis-LR)/LS-Cgap/2),YC(0),XC(-(Laxis-LR)/LS-Cgap/2),YC(1),\n             lty=3,col=\"blue\")\n    segments(XC((Raxis-RL)/RS+Cgap/2),YC(0),XC((Raxis-RL)/RS+Cgap/2),YC(1),\n             lty=3,col=\"blue\")\n  }\n  # axes\n  lines(c(XC(-1-Cgap/2),XC(-Cgap/2)),c(YC(0),YC(0)),lty=1)\n  lines(c(XC(-Cgap/2),XC(-Cgap/2)),c(YC(0),YC(1)),lty=1)\n  lines(c(XC(1+Cgap/2),XC(Cgap/2)),c(YC(0),YC(0)),lty=1)\n  lines(c(XC(Cgap/2),XC(Cgap/2)),c(YC(0),YC(1)),lty=1)\n  # labels\n  text(XC(-0.5-Cgap/2),YC(1),Llab,pos=3)\n  text(XC(0.5+Cgap/2),YC(1),Rlab,pos=3)\n  text(XC(0),YC(1),Clab,pos=3)\n  Ci <- length(Center)\n  for (i in 0:(Ci-1)) { \n    if ((i%%Cstep)==0) { text(XC(0),YC(i/Ci+Cadj),paste(Center[i+1]),pos=3,cex=Csize) }\n  }\n  text(XC(-(Laxis-LR)/LS-Cgap/2),YC(rep(0,LI)),\n       paste(formatC(Laxis,format=AxisFM,big.mark=AxisBM,big.interval=AxisBI)),pos=1)\n  text(XC((Raxis-RL)/RS+Cgap/2),YC(rep(0,RI)),\n       paste(formatC(Raxis,format=AxisFM,big.mark=AxisBM,big.interval=AxisBI)),pos=1)\n  # main text (above the frame)\n  if (length(main)>0) { text(XC(0), YC(1.1), main, pos=3) }\n  # draw rectangles\n  VB <- 0:(Ci-1)/Ci\n  VT <- 1:Ci/Ci\n  LeftP <- -(Left-LR)/LS-Cgap/2\n  rect(XC(LeftP),YC(VB),XC(rep(-Cgap/2,Ci)),YC(VT),col=Lcol,density=Ldens, lwd=linewidth)\n  RightP <- (Right-RL)/RS+Cgap/2\n  rect(XC(rep(Cgap/2,Ci)),YC(VB),XC(RightP),YC(VT),col=Rcol,density=Rdens,lwd=linewidth)\n}\n\npyramide_ages <- function(avant, après,\n                          titre = \"\",\n                          date.début = début.période.sous.revue,\n                          date.fin = fin.période.sous.revue) {\n  plot(c(0,100), c(0,100), type = \"n\", frame = FALSE, axes = FALSE, xlab = \"\", ylab = \"\",\n     main = titre)\n  pyramidf(avant, frame=c(10, 75, 0, 90), linewidth=1)\n  pyramidf(après, frame=c(10, 75, 0, 90), \n           Lcol=\"darkslateblue\", Rcol = \"firebrick4\",\n           #Lcol=\"deepskyblue\", Rcol = \"deeppink\",\n           Ldens = 10, Rdens = 10)\n  legend(\"right\", fill=c(\"cadetblue1\", \"thistle1\", \"darkslateblue\", \"firebrick4\"), density=c(NA, NA, 20, 20),\n         legend=c(\"Hommes \" %+% date.début, \"Femmes \" %+% date.début,\n                  \"Hommes \" %+% date.fin, \"Femmes \" %+% date.fin), cex = 0.8)\n}\n\n",
    "created" : 1455494966209.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3002704693",
    "id" : "874DC543",
    "lastKnownWriteTime" : 1454900879,
    "last_content_update" : 1454900879,
    "path" : "C:/Users/Public/Dev/altair/Tests/Exemple/bibliotheque.fonctions.paie.R",
    "project_path" : "Tests/Exemple/bibliotheque.fonctions.paie.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}