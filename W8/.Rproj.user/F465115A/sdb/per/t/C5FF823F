{
    "contents" : "\n\nlibrary(knitr)\nlibrary(ggplot2)\nlibrary(assertthat)\nlibrary(gtools)\nlibrary(data.table)\n\n## Pour les versions de data.table < 1.9.5 \n##  if (séparateur.décimal.entrée != \".\")\n##  stop(\"Pour les tables importées par data.table::fread, le séparateur décimal doit être '.'\")\n\nif (séparateur.décimal.entrée == séparateur.liste.entrée)\n  stop(\"Le séparateur décimal en entrée doit être différent du séparateur de colonnes !\")\n\nif (séparateur.décimal.sortie == séparateur.liste.sortie)\n  stop(\"Le séparateur décimal en sortie doit être différent du séparateur de colonnes !\")\n\nif (sauvegarder.bases.analyse) {\n  for (path in c(\"Rémunérations\", \"Effectifs\", \"Réglementation\", \"Fiabilité\"))\n    dir.create(file.path(chemin.dossier.bases, path), recursive = TRUE)\n}\n\nif (sauvegarder.bases.origine)\n  dir.create(file.path(chemin.dossier.bases, \"Paiements\"), recursive = TRUE)\n\n# problème temporaire avec l'option fig.retina depuis fin mai 2014\n\nknitr::opts_chunk$set(fig.width = 7.5, echo = FALSE, warning = FALSE, message = FALSE, results = 'asis')\n\n# Contrôle de cohérence\n#  on vérifie que chaque code de paie est associé, dans le fichier des codes de paiement (par défaut, racinecodes.csv),\n#  que à chaque code donné on a associé un et un seul type de rémunération (\"INDEMNITAIRE\", \"TRAITEMENT\", etc.)\n# Pour le mode rapide, convertir les fichiers base en UTF-8 SANS BOM (par exemple, notepad++ après Excel)\n\n\nfichier.personnels.existe <- file.exists(chemin(nom.fichier.personnels))\n\nif (fichier.personnels.existe) {\n  base.personnels.catégorie <- read.csv.skip(nom.fichier.personnels, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée)\n  message(\"Chargement du fichier des catégories statutaires des personnels.\")\n}\n\n# Lignes de paie\n# On peut lire jusqu'à 50 fichiers csv de lignes de paie qui seront générés au format :\n\n# \"chemin dossier + racine-Lignes de Paie-j.csv\" où racine est un bref identifiant du type de contrôle (exemple : \"c2a-\", \"PEV-\", ...)\n\nlignes.paie <- nom.fichier.paie %+% \"-\" %+% 1:50 %+% \".csv\"\nlignes.paie <- lignes.paie[file.exists(chemin(lignes.paie))]\n\n# Bulletins de paie\n# On peut lire jusqu'à 10 fichiers csv de bulletins de paie qui seront générés au format :\n\n# \"chemin dossier + racine-Bulletins de Paie-j.csv\"\n\nbulletins.paie <- nom.bulletin.paie %+% \"-\" %+% 1:10 %+% \".csv\"\nbulletins.paie <- bulletins.paie[file.exists(chemin(bulletins.paie))]\nnom.table      <- nom.table[file.exists(chemin(nom.table))]\n\n# Programme principal\n\n# Bases\n\n# Lignes de paie\n\n# On ne retient que les bases ayant pour années au minimum début.période.sous.revue\n# et au maximum fin.période.sous.revue, qui contiennent toutes les colonnes requises\n# pour le contrôle\n\n# Le mode rapide n'est disponible que avec des csv à séparateurs virgule\n# Il permet d'économiser environ 8s par million de ligne lues sur une dizaine de champs\n\nImport.Lignes.paie <- function()  {\n  \n  res <- NULL\n  res2 <- NULL\n  \n  res <- try(Read.csv(\"Lignes.paie\",\n                      lignes.paie,\n                      colClasses = lignes.paie.classes.input,\n                      colNames = lignes.paie.input.fallback,\n                      séparateur.liste = séparateur.liste.entrée,\n                      séparateur.décimal = séparateur.décimal.entrée,\n                      drop=1:3,\n                      rapide = TRUE),\n             silent = TRUE)\n  \n  if (inherits(res, 'try-error')) {\n    res2 <- try(Read.csv(\"Lignes.paie\",\n                         lignes.paie,\n                         colClasses = lignes.paie.classes.input.fallback,\n                         colNames = lignes.paie.input.fallback,\n                         séparateur.liste = séparateur.liste.entrée,\n                         séparateur.décimal = séparateur.décimal.entrée,\n                         rapide = TRUE),\n                silent = TRUE)\n  }\n  \n  c(res, res2)\n}\n\n\nimporter.bases.via.xhl2csv <- function(base, table = nom.table, colClasses = colonnes.classes.input, colNames =  colonnes.input) {\n  \n  res <- try(Read.csv(base,\n                      table,\n                      colClasses = colClasses,\n                      colNames = colNames,\n                      séparateur.liste = séparateur.liste.entrée,\n                      séparateur.décimal = séparateur.décimal.entrée,\n                      convertir.encodage = (encodage.entrée.xhl2csv != \"UTF-8\"),\n                      encodage = encodage.entrée.xhl2csv,\n                      rapide = TRUE),\n             silent = FALSE)\n  \n  if (inherits(res, 'try-error'))\n    stop(\"Problème de lecture de la base de la table bulletins-lignes de Paie\")\n  \n  if (!is.null(Paie)) {\n    message(\"Chargement de la table bulletins-lignes de Paie.\")\n  } else {\n    stop(\"Chargement de la table bulletins-lignes de paie en échec.\")\n  }\n  \n  message(\"Chargement direct des bulletins et lignes de paie\")\n}\n\n\nif (charger.bases) {\n  importer.bases.via.xhl2csv(\"Paie\")\n  importer.bases.via.xhl2csv(\"Bulletins.paie\", nom.bulletins, colClasses =  colonnes.bulletins.classes.input, colNames = colonnes.bulletins.input)\n  \n  Paie[is.na(Grade),  Grade  := \"\"]\n  Paie[is.na(Statut), Statut := \"AUTRE_STATUT\"]\n  Paie[is.na(NBI),    NBI    := 0]\n  Bulletins.paie[is.na(Grade),  Grade  := \"\"]\n  Bulletins.paie[is.na(Statut), Statut := \"AUTRE_STATUT\"]\n  Bulletins.paie[is.na(NBI),    NBI    := 0]\n}\n\nsetkey(Paie, Matricule, Année, Mois)\nsetkey(Bulletins.paie, Matricule, Année, Mois)\n\nif (! extraire.années) {\n  début.période.sous.revue <- min(Paie[[1]])\n  fin.période.sous.revue   <- max(Paie[[1]])\n}\n\n\n\n# Le format est jour/mois/année avec deux chiffres-séparateur-deux chiffres-séparateur-4 chiffres.\n# Le séparateur peut être changé en un autre en modifiant le \"/\" dans date.format\n\navant.redressement <- 0\naprès.redressement <- 0\n\nif (éliminer.duplications) {\n  avant.redressement <- nrow(Paie)\n  duplications.vecteur <- duplicated(Paie, by=NULL)\n  duplications.paie <- Paie[duplications.vecteur]\n  Paie <- Paie[! duplications.vecteur] \n  \n  sauv.bases(chemin.dossier.bases, \"duplications.paie\")\n  après.redressement <- nrow(Paie)\n  rm(duplications.vecteur)\n}\n\n# dans le cas où l'on ne lance le programme que pour certaines années, il préciser début.période sous revue et fin.période .sous.revue\n# dans le fichier prologue.R. Sinon le programme travaille sur l'ensemble des années disponibles.\n\nif (extraire.années) {\n  Paie <- Paie[Paie$Année >= début.période.sous.revue & Paie$Année <= fin.période.sous.revue, ]\n}\n\npériode                 <- début.période.sous.revue:fin.période.sous.revue\ndurée.sous.revue        <- fin.période.sous.revue - début.période.sous.revue + 1\n\nif (! analyse.statique.totale) {\n  \n  années.analyse.statique <- c(début.période.sous.revue, fin.période.sous.revue)\n  \n} else {\n  \n  années.analyse.statique <- période\n}\n\nmessage(\"Contrôle des noms de colonne des bulletins de paie : normal.\")\n\n# Lors de la PREMIERE utilisation d'Altair, paramétrer générer.codes <- TRUE dans prologue.R\n# pour générer les fichier des codes de paiement sous le dossier des bases (par défaut \"Données\").\n# ce fichier est trier par ordre croissant des codes de paiement sur les trois premiers chiffres des codes\n# des anomalies peuvent résiduellement apparaître avec des codes contenant des lettres, en général après\n# le troisième chiffre du code.\n# L'utilisateur devra alors renseigner la colonne étiquette.type.rémunération de ce fichier\n\nif (générer.codes)   {\n  source(\"générer.codes.R\", encoding = encodage.code.source)\n  générer.base.codes(Paie) \n}\n\nif (charger.bases) {\n  \n  Paie[ , Filtre_actif := any(Montant[Type == \"T\" & Heures > minimum.positif] > minimum.actif, na.rm = TRUE), by=\"Matricule,Année\"]\n  \n  Paie[ , `:=`(delta = sum(Montant * (Type %chin% c(\"I\", \"T\", \"S\", \"IR\", \"AC\",\"A\", \"R\", \"AV\")),\n                           na.rm=TRUE) - Brut),\n       by=\"Matricule,Année,Mois\"]\n  \n  #Bulletins.paie <- unique(Paie[ , .(Matricule, Nom, Année, Mois, Temps.de.travail, Heures,  Statut, Emploi, Grade, Brut, Net.à.Payer, Nir)], by = NULL)\n  \n  Bulletins.paie[ , `:=`(Sexe = substr(Nir, 1, 1),\n                         R    = .I - 1)]\n  \n  # Attention, NA, pas FALSE\n  \n  set(Bulletins.paie, 1, \"R\", NA)\n  \n  \n  # Médiane des services horaires à temps complet par emploi et par sexe \n  \n  # La variable Heures des élus est non fiable et on peut par convention prendre la quotité 1\n  \n  # Pour faciliter les comparaisons de quotité lors du calcul de la RMPP on arrondit les quotités au centième inférieur\n  # Lorsque la déterminéation de la médiane par emploi et sexe du nombre d'heures travaillées à temps complet n'est pas positive, la quotité est indéfinie\n  # Une quotité ne peut pas dépasser 1.\n  # Les élus sont réputés travailler à temps complet.\n  \n  message(\"Calcul des quotités\")\n  \n  #on va trouver la plupart du temps 151,67...\n  # Tableau de référence des matrices de médianes\n  # A ce niveau de généralité, le filtre actif est inutile, sauf peut-être pour de très petits effectifs.\n  \n  \n  M <- Bulletins.paie[(Sexe == \"1\" | Sexe == \"2\") & Heures > minimum.positif, .(Médiane_Sexe_Statut = median(Heures, na.rm=TRUE)), by=\"Sexe,Statut\"]\n  \n  Bulletins.paie <- merge(Bulletins.paie, Paie[, .(Filtre_actif=Filtre_actif[1]), by=\"Matricule,Année,Mois\"], all.x=TRUE, all.y=FALSE)\n  \n  Bulletins.paie[ , pop_calcul_médiane := length(Heures[Temps.de.travail == 100 \n                                                        & !is.na(Heures) \n                                                        & Heures > minimum.positif]), by = \"Sexe,Emploi\"]\n  \n  # Pour les quotités seules les périodes actives sont prises en compte\n  \n  Bulletins.paie[ , MHeures := ifelse(pop_calcul_médiane > population_minimale_calcul_médiane \n                                      & Filtre_actif == TRUE,\n                                      median(Heures[Temps.de.travail == 100 \n                                                    & Filtre_actif == TRUE\n                                                    & Heures > minimum.positif], na.rm = TRUE),\n                                      M[M$Sexe == Bulletins.paie$Sexe\n                                        & M$Statut == Bulletins.paie$Statut,\n                                        Médiane_Sexe_Statut]),\n                 by=\"Sexe,Emploi\"]\n  \n  # L'écrêtement des quotités est une contrainte statistiquement discutable qui permet de \"stresser\" le modèle\n  # Par défaut les quotités sont écrêtées pour pouvoir par la suite raisonner en définissant le temps plein comme quotité == 1\n  \n  if (écreter.quotités) {\n    Bulletins.paie[ , quotité   :=  ifelse(MHeures < minimum.positif, NA, ifelse(Heures > MHeures, 1, round(Heures/MHeures, digits=2)))]  \n  } else {\n    Bulletins.paie[ , quotité   :=  ifelse(MHeures < minimum.positif, NA, round(Heures/MHeures, digits=2))]  \n  }\n  \n  Bulletins.paie[Statut == \"ELU\", `:=`(MHeures = 1,\n                                       quotité = 1)]\n  \n  message(\"Quotités calculées\")\n  \n  Bulletins.paie[ ,   `:=`(Montant.net.eqtp  = ifelse(is.finite(a<-Net.à.Payer/quotité), a,  NA),\n                           Montant.brut.eqtp = ifelse(is.finite(a<-Brut/quotité), a,  NA))]\n  \n  Bulletins.paie[ ,   `:=`(Statut.sortie   = Statut[length(Net.à.Payer)],\n                           nb.jours        = calcul.nb.jours.mois(Mois, Année[1]),\n                           nb.mois         = length(Mois),\n                           quotité.moyenne = round(mean.default(quotité, na.rm = TRUE), digits = 1)),\n                 key=c(\"Matricule\", \"Année\")]\n  \n  # Indicatrice pour la rémunération moyenne des personnes en place :\n  # quotité égale pendant deux années successives contigues, permanence sur 12 mois.\n  # nous prenons les moyennes des quotités non NA.\n  \n  Bulletins.paie[ , indicatrice.quotité.pp := (Matricule[R] == Matricule \n                                               & Année[R]   == Année - 1 \n                                               & quotité.moyenne[R] == quotité.moyenne\n                                               & nb.mois[R] == nb.mois\n                                               & nb.mois    == 12)]\n  \n  Bulletins.paie[ ,   `:=`(Montant.brut.annuel      = sum(Brut, na.rm=TRUE),\n                           Montant.brut.annuel.eqtp = sum(Montant.brut.eqtp * 365 / nb.jours, na.rm=TRUE),\n                           Montant.net.annuel.eqtp  = sum(Montant.net.eqtp * 365 / nb.jours, na.rm=TRUE),\n                           Montant.net.annuel       = sum(Net.à.Payer, na.rm=TRUE),\n                           permanent                = nb.jours >= 365,\n                           cumHSup      = sum(Heures.Sup., na.rm = TRUE), \n                           indicatrice.quotité.pp = indicatrice.quotité.pp[1]),\n                 key=c(\"Matricule\", \"Année\")]\n  \n  message(\"Indicatrice RMPP calculée\")\n  \n  # Obsolète\n  \n  # Bulletins.paie.réduit <- unique(Bulletins.paie[ , .(Matricule, Année, quotité.moyenne)], by = NULL)\n  # \n  # Bulletins.paie.réduit <- Bulletins.paie.réduit[ , nb.années := length(Année), by=\"Matricule\"]\n  # \n  # indicatrice.quotité <- function(matricule, année)  Bulletins.paie.réduit[Matricule == matricule \n  #                                                                          & Année == année, \n  #                                                                            quotité.moyenne][1] ==  Bulletins.paie[Matricule == matricule\n  #                                                                                                                   & (Année == année - 1),\n  #                                                                                                                     quotité.moyenne][1]\n  #                                                   \n  # \n  # Bulletins.paie <- merge(Bulletins.paie, cbind(Bulletins.paie.réduit[ , .(Matricule, Année, nb.années)],\n  #                                               indicatrice.quotité.pp = mapply(indicatrice.quotité,\n  #                                                              Bulletins.paie.réduit[ , Matricule], \n  #                                                              Bulletins.paie.réduit[ , Année],\n  #                                                              USE.NAMES = FALSE)),\n  #                         by = c(\"Matricule\", \"Année\"))\n  # \n  # delta<-Bulletins.paie[indic.rmpp != indicatrice.quotité.pp, .(Matricule, Année, Mois, quotité, quotité.moyenne, indic.rmpp, indicatrice.quotité.pp, R)]\n  # \n  # sauv.bases(dossier = chemin.dossier.bases, \"delta\")\n  # stop(\"test\")\n  \n  Paie <- merge(unique(Bulletins.paie[ , c(\"Matricule\", \n                                           \"Année\",\n                                           \"Mois\",\n                                           \"quotité\",\n                                           \"quotité.moyenne\",\n                                           \"Montant.net.eqtp\",\n                                           \"Montant.brut.eqtp\",\n                                           \"Montant.brut.annuel\",\n                                           \"Montant.brut.annuel.eqtp\",\n                                           \"Montant.net.annuel\",\n                                           \"Montant.net.annuel.eqtp\",\n                                           \"Statut.sortie\",\n                                           \"Sexe\",\n                                           \"nb.jours\",\n                                           \"nb.mois\",\n                                           #                                  \"nb.années\",\n                                           \"indicatrice.quotité.pp\",\n                                           \"permanent\"), with=FALSE], by=NULL),\n                Paie, \n                by=c(\"Matricule\",\"Année\",\"Mois\"))\n  \n  matricules <- unique(Bulletins.paie[ ,\n                                      c(\"Année\",\n                                        \"Emploi\",\n                                        \"Nom\",\n                                        \"Matricule\"), \n                                      with=FALSE], by=NULL)\n  \n  if (fichier.personnels.existe) {\n    matricules <- merge(matricules, base.personnels.catégorie, by = clé.fusion, all=TRUE)\n  } else {\n    Catégorie <- character(length = nrow(matricules))\n    matricules <- cbind(matricules, Catégorie)\n  }\n  \n  matricules <- matricules[order(Matricule,  Année), ]\n  \n  message(\"Bulletins de Paie retraités\")\n  \n} # if (charger.bases)\n",
    "created" : 1421713479403.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "946695134",
    "id" : "C5FF823F",
    "lastKnownWriteTime" : 1421708054,
    "path" : "C:/Dev/altair/Tests/Exemple/import.R",
    "project_path" : "Tests/Exemple/import.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}