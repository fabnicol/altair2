{
    "collab_server" : "",
    "contents" : "\nlibrary(knitr)\nlibrary(ggplot2)\nlibrary(assertthat)\nlibrary(gtools)\nlibrary(data.table)\n\n## Pour les versions de data.table < 1.9.5 \n##  if (séparateur.décimal.entrée != \".\")\n##  stop(\"Pour les tables importées par data.table::fread, le séparateur décimal doit être '.'\")\n\nif (séparateur.décimal.entrée == séparateur.liste.entrée)\n  stop(\"Le séparateur décimal en entrée doit être différent du séparateur de colonnes !\")\n\nif (séparateur.décimal.sortie == séparateur.liste.sortie)\n  stop(\"Le séparateur décimal en sortie doit être différent du séparateur de colonnes !\")\n\nif (sauvegarder.bases.analyse) {\n  for (path in c(\"Rémunérations\", \"Effectifs\", \"Réglementation\", \"Fiabilité\"))\n    dir.create(file.path(chemin.dossier.bases, path), recursive = TRUE)\n}\n\nif (sauvegarder.bases.origine)\n  dir.create(file.path(chemin.dossier.bases, \"Paiements\"), recursive = TRUE)\n\n# problème temporaire avec l'option fig.retina depuis fin mai 2014\n\nknitr::opts_chunk$set(fig.width = 7.5, echo = FALSE, warning = FALSE, message = FALSE, results = 'asis')\n\n# Contrôle de cohérence\n#  on vérifie que chaque code de paie est associé, dans le fichier des codes de paiement (par défaut, racinecodes.csv),\n#  que à chaque code donné on a associé un et un seul type de rémunération (\"INDEMNITAIRE\", \"TRAITEMENT\", etc.)\n# Pour le mode rapide, convertir les fichiers base en UTF-8 SANS BOM (par exemple, notepad++ après Excel)\n\n \nfichier.personnels.existe <- (charger.catégories.personnel == TRUE) & file.exists(chemin(nom.fichier.personnels))\n\nif (fichier.personnels.existe) {\n  base.personnels.catégorie <- read.csv.skip(nom.fichier.personnels, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée)\n  message(\"Chargement du fichier des catégories statutaires des personnels.\")\n}\n\n# Lignes de paie\n# On peut lire jusqu'à 50 fichiers csv de lignes de paie qui seront générés au format :\n\n# \"chemin dossier + racine-Lignes de Paie-j.csv\" où racine est un bref identifiant du type de contrôle (exemple : \"c2a-\", \"PEV-\", ...)\n\nlignes.paie <- nom.fichier.paie %+% \"-\" %+% 1:50 %+% \".csv\"\nlignes.paie <- lignes.paie[file.exists(chemin(lignes.paie))]\n\n# Bulletins de paie\n# On peut lire jusqu'à 10 fichiers csv de bulletins de paie qui seront générés au format :\n\n# \"chemin dossier + racine-Bulletins de Paie-j.csv\"\n\nbulletins.paie <- nom.bulletin.paie %+% \"-\" %+% 1:10 %+% \".csv\"\nbulletins.paie <- bulletins.paie[file.exists(chemin(bulletins.paie))]\nnom.table      <- nom.table[file.exists(chemin(nom.table))]\n\n# Programme principal\n\n# Bases\n\n# Lignes de paie\n\n# On ne retient que les bases ayant pour années au minimum début.période.sous.revue\n# et au maximum fin.période.sous.revue, qui contiennent toutes les colonnes requises\n# pour le contrôle\n\n# Le mode rapide n'est disponible que avec des csv à séparateurs virgule\n# Il permet d'économiser environ 8s par million de ligne lues sur une dizaine de champs\n\n\nimporter.bases.via.xhl2csv <- function(base, table = nom.table, colClasses = colonnes.classes.input, colNames =  colonnes.input) {\n  \n  res <- try(Read.csv(base,\n                      table,\n                      colClasses = colClasses,\n                      colNames = colNames,\n                      séparateur.liste = séparateur.liste.entrée,\n                      séparateur.décimal = séparateur.décimal.entrée,\n                      convertir.encodage = FALSE, #(encodage.entrée.xhl2csv != \"UTF-8\"),\n                      encodage = encodage.entrée.xhl2csv,\n                      rapide = TRUE),\n             silent = FALSE)\n  \n  if (inherits(res, 'try-error'))\n    stop(\"Problème de lecture de la base de la table bulletins-lignes de Paie\")\n  \n  if (!is.null(Paie)) {\n    message(\"Chargement de la table bulletins-lignes de Paie.\")\n  } else {\n    stop(\"Chargement de la table bulletins-lignes de paie en échec.\")\n  }\n  \n  message(\"Chargement direct des bulletins et lignes de paie\")\n}\n\n\nif (charger.bases) {\n  importer.bases.via.xhl2csv(\"Paie\",colClasses =  colonnes.classes.input)\n  importer.bases.via.xhl2csv(\"Bulletins.paie\", nom.bulletins, colClasses =  colonnes.bulletins.classes.input, colNames = colonnes.bulletins.input)\n  \n  # dans le cas où l'on ne lance le programme que pour certaines années, il préciser début.période sous revue et fin.période .sous.revue\n  # dans le fichier prologue.R. Sinon le programme travaille sur l'ensemble des années disponibles.\n  \n  if (extraire.années) {\n    Paie <- Paie[Année >= début.période.sous.revue & Année <= fin.période.sous.revue, ]\n    Bulletins.paie <- Bulletins.paie[Année >= début.période.sous.revue & Année <= fin.période.sous.revue, ]\n  } else {\n    début.période.sous.revue <- min(Paie[[1]])\n    fin.période.sous.revue   <- max(Paie[[1]])\n  }\n  \n  \n  Paie[is.na(Grade),  Grade  := \"\"]\n  Paie[is.na(Statut), Statut := \"AUTRE_STATUT\"]\n  Paie[is.na(NBI),    NBI    := 0]\n  Bulletins.paie[is.na(Grade),  Grade  := \"\"]\n  Bulletins.paie[is.na(Statut), Statut := \"AUTRE_STATUT\"]\n  Bulletins.paie[is.na(NBI),    NBI    := 0]\n}\n\npériode                 <- début.période.sous.revue:fin.période.sous.revue\ndurée.sous.revue        <- fin.période.sous.revue - début.période.sous.revue + 1\n\nif (! analyse.statique.totale) {\n  \n  années.analyse.statique <- c(début.période.sous.revue, fin.période.sous.revue)\n  \n} else {\n  \n  années.analyse.statique <- période\n}\n\nsetkey(Paie, Matricule, Année, Mois)\nsetkey(Bulletins.paie, Matricule, Année, Mois)\n\n\n# Le format est jour/mois/année avec deux chiffres-séparateur-deux chiffres-séparateur-4 chiffres.\n# Le séparateur peut être changé en un autre en modifiant le \"/\" dans date.format\n\navant.redressement <- 0\naprès.redressement <- 0\n  \nif (éliminer.duplications) {\n  avant.redressement <- nrow(Paie)\n  duplications.vecteur <- duplicated(Paie, by=NULL)\n  duplications.paie <- Paie[duplications.vecteur & Montant != 0]\n  Paie <- Paie[! duplications.vecteur] \n  if (sauvegarder.bases.origine)\n      sauv.bases(chemin.dossier.bases, \"duplications.paie\")\n  après.redressement <- nrow(Paie)\n  \n  avant.redressement.bull <- nrow(Bulletins.paie)\n  duplications.vecteur   <- duplicated(Bulletins.paie, by=NULL)\n  duplications.paie.bull <- Bulletins.paie[duplications.vecteur & Montant != 0]\n  Bulletins.paie <- Bulletins.paie[! duplications.vecteur] \n  if (sauvegarder.bases.origine) {\n    sauv.bases(chemin.dossier.bases, \"duplications.paie\")\n    sauv.bases(chemin.dossier.bases, \"duplications.paie.bull\")\n  }\n  après.redressement.bull <- nrow(Bulletins.paie)\n  rm(duplications.vecteur)\n  \n} \n  \n\n# calcul du temps complet mensuel de référence en h/mois\n\nquotité.temps.partiel <- function(temps.de.travail) {\n  \n  if (x == 90) return(0.91429)  # 32/35 \n  if (x == 80) return(0.85714)  # 6/7   \n  return(x/100)\n  \n}\n\nverif.temps.complet <- function() {\n  \n  # dans certains cas on a presque jamais la variable Heures renseignée... sauf pour quelques temps partiels\n  \n  h <- hist(Bulletins.paie[Temps.de.travail == 100, Heures], nclass = 20000, plot = FALSE)\n  max.h <- which.max(h$counts)\n  \n  if (max.h > 1) {\n    \n    delta <- (h$mids[max.h + 1] - h$mids[max.h - 1])/2\n    \n    if (is.na(delta)) delta <<- 1 #Présomption\n    \n    nb.heures.temps.complet <<- floor(h$mids[max.h])\n    \n  } else {\n    \n    return(TRUE) # présomption\n  }\n  \n  valeur <- (abs(nb.heures.temps.complet - 151.67) < 1 + delta)  \n  \n  if (is.na(valeur))  {\n    valeur <- TRUE # présomption\n  }\n  \n  return(valeur)\n}\n\nmessage(\"Vérification de la durée légale théorique du travail (1820 h = 35h x 52 semaines soit 151,67 h/mois)\")\n\ntest.temps.complet <<- verif.temps.complet()\n\nif (test.temps.complet) {\n\n  nb.heures.temps.complet <<- 151.67  #  1820 / 12\n  \n} else {\n  \n  nb.heures.temps.complet <<- floor(nb.heures.temps.complet)\n\n}\n\n# si l'on a une cohérence du calcul des heures de travail par semaine alors peut se baser dessus :\n\nif (redresser.heures) {\n  \n  # On ne peut pas inférer sur quotite Trav (Temps.de.travail) de manière générale\n  # Mais on peut exclure les cas dans lesquels Temps de travail est non fiable puis déduire en inférence sur ce qui reste\n  # critère d'exclusion envisageable pour les stats de rémunérations à quotités :\n  # Paie[Indice == \"\" & Type %chin% c(\"T\", \"I\", \"A\", \"AC\") & Heures == 0 | Statut %chin% c(\"ELU\", \"v\", \"A\")]\n  # sur le reste on peut inférer Heures \n  \n  setnames(Paie, \"Heures\", \"Heures.orig\")\n  setnames(Bulletins.paie, \"Heures\", \"Heures.orig\")\n  Paie[ , Heures := Heures.orig]\n  Bulletins.paie[ , Heures := Heures.orig]\n  \nif (test.temps.complet) {\n  \n  Paie[(Heures == 0 | is.na(Heures))\n       & Indice != \"\" & !is.na(Indice) \n       & Statut != \"ELU\" & Grade != \"V\" & Grade!= \"A\"\n       & Temps.de.travail != 0 & !is.na(Temps.de.travail), `:=`(indic = TRUE, \n                                                                Heures = round(Temps.de.travail * nb.heures.temps.complet / 100, 1))]\n  \n  \n  Bulletins.paie[(Heures == 0 | is.na(Heures))\n                 & Indice != \"\" & !is.na(Indice) \n                 & Statut != \"ELU\" & Grade != \"V\" & Grade!= \"A\"\n                 & Temps.de.travail != 0 & !is.na(Temps.de.travail), \n                 `:=`(indic = TRUE, \n                      Heures = round(Temps.de.travail * nb.heures.temps.complet / 100, 1))]\n  \n  message(\"Correction (méthode 1), compte tenu des temps complets vérifiés, sur \", nredressements <<- nrow(Bulletins.paie[indic == TRUE]), \" bulletins de paie\")\n  \n} else {\n  \n  # on présume alors que les traitements sont correctement liquidés... il faudrait mettre un drapeau sur cette présomption  \n  \n  Paie[ , indic := (Heures == 0 | is.na(Heures))\n             & Indice != \"\" & !is.na(Indice) \n             & Statut != \"ELU\" & Grade != \"V\" & Grade!= \"A\"\n             & Temps.de.travail != 0 & !is.na(Temps.de.travail)\n             & Type == \"T\" & Montant > 0\n             & grepl(\".*salaire|trait.*\", Libellé, perl=TRUE, ignore.case=TRUE)]\n  \n  # attention ifelse pas if...else\n  \n  Paie[indic == TRUE , Heures := ifelse(!is.na(as.numeric(Indice)) & is.finite(Montant/as.numeric(Indice)), \n                                     Montant / (as.numeric(Indice) * PointMensuelIM[Année - 2007, Mois]) * 151.67, NA)]\n  \n  Bulletins.paie <- merge(unique(Paie[ , .(Matricule, \n                                           Année,\n                                           Mois,\n                                           Service,\n                                           Statut,\n                                           Heures,\n                                           indic)], by=NULL),\n                Bulletins.paie[, Heures := NULL], \n                by = c(\"Matricule\",\"Année\",\"Mois\",\"Service\", \"Statut\"))\n  \n  message(\"Correction (méthode 2), compte tenu des temps complets vérifiés, sur \", nredressements <<- nrow(Bulletins.paie[indic == TRUE]), \" lignes de paie\")\n }\n}\n\n# Lors de la PREMIERE utilisation d'Altair, paramétrer générer.codes <- TRUE dans prologue.R\n# pour générer les fichier des codes de paiement sous le dossier des bases (par défaut \"Données\").\n# ce fichier est trier par ordre croissant des codes de paiement sur les trois premiers chiffres des codes\n# des anomalies peuvent résiduellement apparaître avec des codes contenant des lettres, en général après\n# le troisième chiffre du code.\n# L'utilisateur devra alors renseigner la colonne étiquette.type.rémunération de ce fichier\n\nif (générer.codes)   {\n  source(\"générer.codes.R\", encoding = encodage.code.source)\n  générer.base.codes(Paie) \n}\n\nif (charger.bases) {\n  \n  Paie[ , Filtre_actif := any(Montant[Type == \"T\" & Heures > minimum.positif] > minimum.actif, na.rm = TRUE), by=\"Matricule,Année\"]\n  \n  Paie[ , delta := 0, by=\"Matricule,Année,Mois\"]\n  \n  Paie[Type %chin% c(\"I\", \"T\", \"S\", \"IR\", \"AC\",\"A\", \"R\", \"AV\") , delta := sum(Montant,  na.rm=TRUE) - Brut, by=\"Matricule,Année,Mois\"]\n  \n  #Bulletins.paie <- unique(Paie[ , .(Matricule, Nom, Année, Mois, Temps.de.travail, Heures,  Statut, Emploi, Grade, Brut, Net.à.Payer, Nir)], by = NULL)\n  \n  Bulletins.paie[ , `:=`(Sexe = substr(Nir, 1, 1),\n                         R    = .I - 1)]\n  \n  # Attention, NA, pas FALSE\n  \n  set(Bulletins.paie, 1, \"R\", NA)\n  \n  \n  # Médiane des services horaires à temps complet par emploi et par sexe \n  \n  # La variable Heures des élus est non fiable et on peut par convention prendre la quotité 1\n  \n  # Pour faciliter les comparaisons de quotité lors du calcul de la RMPP on arrondit les quotités au centième inférieur\n  # Lorsque la déterminéation de la médiane par emploi et sexe du nombre d'heures travaillées à temps complet n'est pas positive, la quotité est indéfinie\n  # Une quotité ne peut pas dépasser 1.\n  # Les élus sont réputés travailler à temps complet.\n  \n  message(\"Calcul des quotités\")\n  \n  #on va trouver la plupart du temps 151,67...\n  # Tableau de référence des matrices de médianes\n  # A ce niveau de généralité, le filtre actif est inutile, sauf peut-être pour de très petits effectifs.\n  \n  \n  M <- Bulletins.paie[(Sexe == \"1\" | Sexe == \"2\") & Heures > minimum.positif, .(Médiane_Sexe_Statut = median(Heures, na.rm=TRUE)), by=\"Sexe,Statut\"]\n  \n  Bulletins.paie <- merge(Bulletins.paie, Paie[, .(Filtre_actif=Filtre_actif[1]), by=\"Matricule,Année,Mois\"], all.x=TRUE, all.y=FALSE)\n  \n  Bulletins.paie[ , pop_calcul_médiane := length(Heures[Temps.de.travail == 100 \n                                                        & !is.na(Heures) \n                                                        & Heures > minimum.positif]), by = \"Sexe,Emploi\"]\n  \n  # Pour les quotités seules les périodes actives sont prises en compte\n  \n  Bulletins.paie[ , MHeures := ifelse(pop_calcul_médiane > population_minimale_calcul_médiane \n                                      & Filtre_actif == TRUE,\n                                      median(Heures[Temps.de.travail == 100 \n                                                    & Filtre_actif == TRUE\n                                                    & Heures > minimum.positif], na.rm = TRUE),\n                                      M[M$Sexe == Bulletins.paie$Sexe\n                                        & M$Statut == Bulletins.paie$Statut,\n                                        Médiane_Sexe_Statut]),\n                 by=\"Sexe,Emploi\"]\n  \n  # L'écrêtement des quotités est une contrainte statistiquement discutable qui permet de \"stresser\" le modèle\n  # Par défaut les quotités sont écrêtées pour pouvoir par la suite raisonner en définissant le temps plein comme quotité == 1\n  \n  if (écreter.quotités) {\n    Bulletins.paie[ , quotité   :=  ifelse(MHeures < minimum.positif, NA, ifelse(Heures > MHeures, 1, round(Heures/MHeures, digits=2)))]  \n  } else {\n    Bulletins.paie[ , quotité   :=  ifelse(MHeures < minimum.positif, NA, round(Heures/MHeures, digits=2))]  \n  }\n  \n  Bulletins.paie[Statut == \"ELU\", `:=`(MHeures = 1,\n                                       quotité = 1)]\n  \n  message(\"Quotités calculées\")\n  \n  Bulletins.paie[ ,   `:=`(Montant.net.eqtp  = ifelse(is.finite(a<-Net.à.Payer/quotité), a,  NA),\n                           Montant.brut.eqtp = ifelse(is.finite(a<-Brut/quotité), a,  NA))]\n  \n  Bulletins.paie[ ,   `:=`(Statut.sortie   = Statut[length(Net.à.Payer)],\n                           nb.jours        = calcul.nb.jours.mois(Mois, Année[1]),\n                           nb.mois         = length(Mois),\n                           cumHeures       = sum(Heures, na.rm = TRUE),\n                           quotité.moyenne = round(mean.default(quotité, na.rm = TRUE), digits = 1)),\n                 key=c(\"Matricule\", \"Année\")]\n  \n  # Indicatrice pour la rémunération moyenne des personnes en place :\n  # quotité égale pendant deux années successives contigues, permanence sur 12 mois.\n  # nous prenons les moyennes des quotités non NA.\n  \n  Bulletins.paie[ , indicatrice.quotité.pp := (Matricule[R] == Matricule \n                                               & Année[R]   == Année - 1 \n                                               & quotité.moyenne[R] == quotité.moyenne\n                                               & nb.mois[R] == nb.mois\n                                               & nb.mois    == 12)]\n  \n  Bulletins.paie[ ,   `:=`(Montant.brut.annuel      = sum(Brut, na.rm=TRUE),\n                           Montant.brut.annuel.eqtp = sum(Montant.brut.eqtp * 365 / nb.jours, na.rm=TRUE),\n                           Montant.net.annuel.eqtp  = sum(Montant.net.eqtp * 365 / nb.jours, na.rm=TRUE),\n                           Montant.net.annuel       = sum(Net.à.Payer, na.rm=TRUE),\n                           permanent                = nb.jours >= 365,\n                           cumHSup      = sum(Heures.Sup., na.rm = TRUE), \n                           indicatrice.quotité.pp = indicatrice.quotité.pp[1]),\n                 key=c(\"Matricule\", \"Année\")]\n  \n  message(\"Indicatrice RMPP calculée\")\n  \n  # Obsolète\n  \n  # Bulletins.paie.réduit <- unique(Bulletins.paie[ , .(Matricule, Année, quotité.moyenne)], by = NULL)\n  # \n  # Bulletins.paie.réduit <- Bulletins.paie.réduit[ , nb.années := length(Année), by=\"Matricule\"]\n  # \n  # indicatrice.quotité <- function(matricule, année)  Bulletins.paie.réduit[Matricule == matricule \n  #                                                                          & Année == année, \n  #                                                                            quotité.moyenne][1] ==  Bulletins.paie[Matricule == matricule\n  #                                                                                                                   & (Année == année - 1),\n  #                                                                                                                     quotité.moyenne][1]\n  #                                                   \n  # \n  # Bulletins.paie <- merge(Bulletins.paie, cbind(Bulletins.paie.réduit[ , .(Matricule, Année, nb.années)],\n  #                                               indicatrice.quotité.pp = mapply(indicatrice.quotité,\n  #                                                              Bulletins.paie.réduit[ , Matricule], \n  #                                                              Bulletins.paie.réduit[ , Année],\n  #                                                              USE.NAMES = FALSE)),\n  #                         by = c(\"Matricule\", \"Année\"))\n  # \n  # delta<-Bulletins.paie[indic.rmpp != indicatrice.quotité.pp, .(Matricule, Année, Mois, quotité, quotité.moyenne, indic.rmpp, indicatrice.quotité.pp, R)]\n  # \n  # sauv.bases(dossier = chemin.dossier.bases, \"delta\")\n  # stop(\"test\")\n  \n  Paie <- merge(unique(Bulletins.paie[ , c(\"Matricule\", \n                                           \"Année\",\n                                           \"Mois\",\n                                           \"Service\",\n                                           \"Statut\",\n                                           \"cumHeures\",\n                                           \"quotité\",\n                                           \"quotité.moyenne\",\n                                           \"Montant.net.eqtp\",\n                                           \"Montant.brut.eqtp\",\n                                           \"Montant.brut.annuel\",\n                                           \"Montant.brut.annuel.eqtp\",\n                                           \"Montant.net.annuel\",\n                                           \"Montant.net.annuel.eqtp\",\n                                           \"Statut.sortie\",\n                                           \"Sexe\",\n                                           \"nb.jours\",\n                                           \"nb.mois\",\n                                           \"indicatrice.quotité.pp\",\n                                           \"permanent\"), with=FALSE], by=NULL),\n                Paie, \n                by=c(\"Matricule\",\"Année\",\"Mois\",\"Service\", \"Statut\"))\n  \n  matricules <- unique(Bulletins.paie[ ,\n                                      c(\"Année\",\n                                        \"Emploi\",\n                                        \"Nom\",\n                                        \"Matricule\"), \n                                      with=FALSE], by=NULL)\n  \n  if (fichier.personnels.existe) {\n    matricules <- merge(matricules, base.personnels.catégorie, by = clé.fusion, all=TRUE)\n  } else {\n    Catégorie <- character(length = nrow(matricules))\n    matricules <- cbind(matricules, Catégorie)\n  }\n  \n  matricules <- matricules[order(Matricule,  Année), ]\n  \n  \n  \n} # if (charger.bases)\n",
    "created" : 1447886128319.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3391315484",
    "id" : "F5C94D6A",
    "lastKnownWriteTime" : 1447887135,
    "path" : "C:/Users/Public/Dev/altair/Tests/Exemple/import.R",
    "project_path" : "Tests/Exemple/import.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}