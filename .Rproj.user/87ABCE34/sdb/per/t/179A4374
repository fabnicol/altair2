{
    "contents" : "##\n#  Fonctions auxiliaires\n##\n\nlibrary(MASS)\n\nchemin <-  function(fichier)\n  file.path(chemin.dossier.données, fichier)\n\nfile2utf8 <- function(nom, encodage.in = encodage.entrée)  {\n  \n chem <- chemin(nom)\n err <- system2(iconv, c(\"-f\", encodage.in, \"-t\", \"UTF-8\", shQuote(chem), \"-o\", \"temp\"))\n if (! err)  err <- system2(\"mv\", c(\"temp\", shQuote(chem))) else stop(\"Erreur d'encodage avec iconv\")\n if (! err)  message(\"Conversion réussie\") else stop(\"Erreur de copie fichier après encodage avec iconv\")\n}\n\nen.séparateurs <- function(chem)  {\n\n  commande <- sed %+% \" -e s/,/\\\\./g -e s/;/,/g -i \" %+% shQuote(chem)\n  shell(commande)\n}\n\nfr.séparateurs <- function(chem)  {\n  \n  commande <- sed %+% \" -e s/,/;/g -e s/\\\\./,/g -i \" %+% shQuote(chem)\n  shell(commande)\n}\n\n\n# Trouve le numéro de la ligne à laquelle se situe la liste des noms de variables\n# en recherchant soit le mot \"Matricule\" soit une expression du type \"Code...\"\n# Il faudra déduire ce \"skip\" du read.csv pour récupérer proprement les noms de variable\n\n# Pour cela on scanne les 25 premières lignes de la table une première fois\n\n\ntrouver.valeur.skip <-  function(chemin.table, encodage, classes = NA, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée)\n  max(\n    sapply(\n      read.csv(chemin.table, sep=séparateur.liste, dec=séparateur.décimal, nrows = 25, fileEncoding = encodage.entrée, colClasses = classes),\n      function(x)\n      {\n        m <- match(champ.détection.1, x, nomatch = 0 )\n        if (m == 0)\n          m <- pmatch(champ.détection.2, x, nomatch = 0, duplicates.ok = FALSE )\n        return(m)\n      }\n    ))\n\n\n# selectionner.cle.matricule <-  function(Base1, Base2)\n# {\n#   if (fusionner.nom.prénom) {\n#      subset(Base1,\n#            select = c(\"Nom\", \"Prénom\", étiquette.matricule, setdiff(names(Base1),names(Base2))))\n#     } else {\n#      subset(Base1,\n#          select = c(étiquette.matricule, setdiff(names(Base1), names(Base2))))\n#     }\n# }\n\nsélectionner.clé <-  function(base1, base2)\n{\n  Base1 <- get(base1)\n  Base2 <- get(base2)\n\n  if (fusionner.nom.prénom) {\n\n    Set1 <- c(\"Mois\", \"Année\", étiquette.matricule, setdiff(names(Base1), names(Base2)))\n    Set2 <- setdiff(names(Base2), c(\"Nom\", \"Prénom\", étiquette.matricule))\n\n    assign(base1,\n           subset(Base1, select = c(\"Nom\", \"Prénom\", Set1)),\n           envir = .GlobalEnv)\n\n    assign(base1,\n           cbind(as.data.frame(convertir.nom.prénom.majuscules(Base1[, c(\"Nom\", \"Prénom\")])),\n                 Base1[, Set1]),\n           envir = .GlobalEnv)\n\n    assign(base2,\n           cbind(as.data.frame(convertir.nom.prénom.majuscules(Base2[, c(\"Nom\", \"Prénom\")])),\n                 Base2[, Set2]),\n           envir = .GlobalEnv)\n\n\n\n  } else {\n\n    assign(base1, subset(Base1,\n                         select = c(étiquette.matricule,\"Mois\",\"Année\",\n                         setdiff(names(Base1), names(Base2)))), envir = .GlobalEnv)\n\n  }\n}\n\n#chem.dot <- paste0(\"\\'\",chem, \".dot\", \"\\'\")\n#system(paste0(\"sed -e s/,/\\\\./g < \\'\", chem,\"\\' > \", chem.dot), wait = TRUE)\n\n\nread.csv.skip <- function(x, encodage = encodage.entrée, classes = NA, étiquettes = NULL, drop = NULL,\n                          rapide = FALSE, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée,\n                          convertir.encodage = TRUE)\n{\n  chem <- chemin(x)\n  if (! rapide) {\n\n    T <- read.csv(chem,\n                   comment.char = \"\",\n                   sep =séparateur.liste,\n                   dec = séparateur.décimal,\n                   colClasses = classes,\n                   skip = trouver.valeur.skip(chem, encodage, séparateur.liste = séparateur.liste, séparateur.décimal = séparateur.décimal),\n                   encoding = encodage)\n\n    if (!is.null(drop)) { T <- T[-(drop)] }\n\n  } else {\n    \n    if (encodage != \"UTF-8\" && convertir.encodage) {\n      message(\"La table en entrée doit être encodée en UTF-8\")\n      if (convertir.encodage) message(\"Conversion via iconv du format \" %+% encodage %+% \" au format UTF-8...\") else stop(\"Arrêt : convertir l'encodage de la table en UTF-8.\")\n      file2utf8(x, encodage.in = encodage)\n    }\n      \n    if (is.na(classes)) classes = NULL\n    T <- try(data.table::fread(chem,\n                      sep = séparateur.liste,\n                      header = TRUE,\n                      verbose = FALSE,\n                      skip = champ.détection.1,\n                      colClasses = classes,\n                      showProgress = FALSE))\n    \n    if (inherits(T, \"try-error\") && grepl(\"The supplied 'sep' was not found\", T, fixed = TRUE)) {\n      message(\"Conversion des séparateurs...\")\n      en.séparateurs(chem)\n      message(\"Séparateurs convertis.\")\n      T <- read.csv.skip (x, \n                    encodage,\n                    classes,\n                    étiquettes,\n                    drop,\n                    rapide,\n                    séparateur.liste,\n                    séparateur.décimal)\n    }\n  }\n\nif (!is.null(étiquettes)) names(T) <- étiquettes\n\n\nreturn(T)\n}\n\nSauv.base <- function(chemin.dossier, nom, nom.sauv, encodage = encodage.sortie, sep = séparateur.liste.sortie, dec = séparateur.décimal.sortie)\n{\n  message(\"Sauvegarde de \", nom)\n  write.table(get(nom),\n             paste0(chemin.dossier, \"/\", iconv(nom.sauv, to = encodage, mark = FALSE), \".csv\"), \n             quote = FALSE,\n             sep = sep,\n             dec = dec,\n             row.names = FALSE,\n             fileEncoding = encodage)\n}\n\nsauv.bases <- function(dossier, ...)\n{\n  if (!see_if(is.dir(dossier)))\n  {\n    stop(\"Pas de dossier de travail spécifié\")\n  }\n\n  tmp <- as.list(match.call())\n  tmp[1] <- NULL\n\n  message(\"Dans le dossier \", dossier,\" :\")\n  invisible(lapply(tmp[-1], function(x) if (exists(x)) Sauv.base(dossier, x, x)))\n}\n\n# Utiliser une assignation globale\n# car la fonction anonyme ne comporte que de variables locales\n\nRead.csv <- function(base.string, vect.chemin, charger = charger.bases, colClasses = NA, colNames = NULL,\n                     drop = NULL, séparateur.liste = séparateur.décimal.entrée, séparateur.décimal = séparateur.décimal.entrée,\n                     rapide = FALSE, convertir.encodage = TRUE, encodage = encodage.entrée)  {\n\n    if (charger.bases) {\n\n        assign(base.string,\n               do.call(rbind, lapply(vect.chemin,\n                                     read.csv.skip,\n                                        classes = colClasses,\n                                        étiquettes = colNames,\n                                        séparateur.liste = séparateur.liste,\n                                        séparateur.décimal = séparateur.décimal,\n                                        drop = drop,\n                                        convertir.encodage = convertir.encodage,\n                                        encodage = encodage,\n                                        rapide = rapide)),\n               envir = .GlobalEnv)\n    }\n}\n\npretty.print <- function(x) cat(gsub(\".\", \" \",deparse(substitute(x)), fixed = TRUE), \"   \", x,\"\\n\")\n\nRésumé <- function(x,y, align = 'r', extra = 0, ...)  {\n    \n     Y <- na.omit(y)\n\n     S <- cbind(c(\"Minimum\", \"1er quartile\", \"Médiane\", \"Moyenne\", \"3ème quartile\", \"Maximum\"),\n                prettyNum(sub(\"[M13].*:\", \"\", summary(Y, ...)), big.mark = \" \"))\n     \n     if (! missing(extra))\n        if (extra == \"length\") {\n          L <- if (is.vector(Y)) length(Y) else nrow(Y)\n          S <- cbind(S, c(\"\", \"\", \"\", L, \"\", \"\"))\n        } else {\n        if (is.numeric(extra))\n                S <- cbind(S, c(\"\", \"\", \"\", as.character(extra), \"\", \"\"))\n        }\n\n     dimnames(S)[[2]] <- c(\"Statistique\", x)\n\n     kable(S, row.names = FALSE, align = align)\n}\n\nTableau <- function(x, ...)\n{\n  V <- c(...)\n  if (\"sep.milliers\" %in% names(V))\n  {\n    sep.milliers <- V[\"sep.milliers\"]\n    V$sep.milliers <- NULL\n  }  else\n  sep.milliers <- \" \"\n\n  T <- t(prettyNum(V, big.mark = sep.milliers))\n  T <- as.data.frame(T)\n  names(T) <- x\n  kable(T, row.names = FALSE, align = \"c\")\n}\n\nTableau.vertical <- function(colnames, rownames, extra = \"\", ...)\n{\n    tmp <- c(...)\n   \n    if (! all(lapply(tmp, is.function))) {\n      message(\"all arguments must be functions\")\n      return(\"\")\n    }\n    \n    lr <- length(rownames)\n    \n    h <- function(x) as.numeric(sub(\",\",\".\", sub(\" \", \"\", x, fixed=T), fixed=T))\n    \n    g <- function(f) {\n        S <- rep(\"\", lr)\n    \n        S[ceiling(lr/2)] <- as.character(prettyNum((h(f(rownames[lr]))/h(f(rownames[1])) - 1) * 100, digits = 3))\n    \n        S\n    }\n      \n  \n    if (! missing(extra) && (is.character(extra)) && (extra == \"variation\")) {\n      T <- data.frame(rownames)\n      NT <- colnames[1]\n      ltmp <- length(tmp)\n      for (x in seq_len(ltmp)) {\n        T <- cbind(T, sapply(rownames, tmp[[x]]), g(tmp[[x]]))\n        NT <- c(NT, colnames[[x + 1]], \"Variation (%)\")\n      }\n    \n      names(T) <- NT\n    } else {\n      T <- data.frame(rownames, lapply(tmp, function(f) sapply(rownames, f)))\n      names(T) <- colnames\n    }\n    \n    kable(T, row.names = FALSE, align = \"c\")\n}\n\nTableau.vertical2 <- function(colnames, rownames, ...)\n{\n  tmp <- list(...)\n  \n  T <- data.frame(rownames, \n                  lapply(tmp, function(y) formatC(y, \n                                                          big.mark=\" \",\n                                                          width=\"12\",\n                                                          format=\"f\",\n                                                          digits=1,\n                                                          decimal.mark=\",\",\n                                                          preserve.width=\"common\")))\n  names(T) <- colnames\n\n  kable(T, row.names = FALSE, align = NULL)\n}\n\n\n#   julian.date.début.période <- julian(as.Date(paste0(\"01/01/\", début.période.sous.revue), date.format))\n#   julian.exercice.suivant.premier <- julian(as.Date(paste0(\"01/01/\",(début.période.sous.revue+1)), date.format))\n#   julian.date.fin.période   <- julian(as.Date(paste0(\"01/01/\", fin.période.sous.revue+1), date.format))\n#   julian.exercice.dernier <- julian(as.Date(paste0(\"01/01/\",fin.période.sous.revue), date.format))\n# \n# calcul.nb.jours <- function(entrée, sortie)\n# {\n# \n#   julian.entrée <-\n#     ifelse(entrée == \"\",\n#            julian.date.début.période,\n#            max(julian.date.début.période, julian(as.Date(entrée, date.format))))\n# \n#   julian.sortie <-\n#     ifelse(sortie == \"\",\n#            julian.date.fin.période,\n#            min(julian.date.fin.période, julian(as.Date(sortie, date.format))))\n# \n#   return (julian.sortie - julian.entrée)\n# }\n# \n# calcul.nb.jours.mois.deprecated <- function(mois.entrée, mois.sortie, année)\n# {\n# \n#   # calcul exact pour une période continue \n#     \n#   if (mois.sortie < mois.entrée) return(0);\n# \n#   if (mois.sortie == 12)\n#   {\n#      année.sortie <- année +1\n#      mois.sortie = 1\n#   }\n#   else\n#   {\n#     année.sortie <- année\n#     mois.sortie <- mois.sortie + 1\n#   }\n# \n#    as.numeric(as.Date(paste0(\"01\",\n#                                   formatC(mois.sortie, width = 2, flag = \"0\"),\n#                                   année.sortie),\n#                       \"%d%m%Y\")\n#               - as.Date(paste0(\"01\",\n#                                    formatC(mois.entrée, width = 2, flag = \"0\"),\n#                                    année),\n#                             \"%d%m%Y\"))\n# }\n\nv.jmois  <-  c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\nv.jmois.leap  <-  c(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\ncalcul.nb.jours.mois <- function(Mois, année)   if ((année - 2008) %%4 == 0) {\n    return(sum(v.jmois.leap[Mois])) \n    } else {\n    return(sum(v.jmois[Mois]))\n  }\n    \n\npositive <- function(X) X[!is.na(X) & X > 0]\nnon.null <- function(X) X[!is.na(X) & X != 0]\nsignificatif <- function(x) !is.na(x) & abs(x) > 0.01\n\ninstaller.paquet <- function(paquet, rigoureusement = FALSE)\n{\n  if (missing(paquet))  return(NA_character_)\n  Paquet <- deparse(paquet)\n  if (length(find.package(Paquet, quiet = TRUE)) == 0)\n  {\n    install.packages(Paquet)\n    if (length(find.package(Paquet, quiet = TRUE)) !=0 )\n    {\n      message(Paquet, \" a été installé.\")\n      return(invisible(1))\n    }\n    else\n    {\n      message(Paquet, \" n'a pas été installé.\")\n      if (rigoureusement == TRUE)\n      {\n        message(\"Arrêt: le paquet \", Paquet, \" n'a pas pu être installé.\")\n        stop(\"Fin\")\n      }\n      return(invisible(0))\n    }\n  }\n  else\n    message(Paquet, \" est déjà installé.\")\n  return(invisible(0))\n}\n\ninstaller.paquets <- function(..., rigoureusement = FALSE)\n{\n  tmp <- as.list(match.call())\n  tmp[1] <- NULL\n  if (!missing(rigoureusement)) tmp[length(tmp)] <- NULL\n  if (length(tmp) == 0) return(0)\n\n  invisible(do.call(sum, lapply(tmp, function(x) installer.paquet(x, rigoureusement))))\n}\n\nconvertir.nom.prénom.majuscules <- function(S)\n{\n\n  S[ , c(\"Nom\", \"Prénom\")] <- apply(S[ , c(\"Nom\", \"Prénom\")],\n                                    2,\n                                    function(x)\n                                      toupper(chartr(\"éèôâçë\",\"eeoaice\", x)))\n\n\n}\n\n#Age fin décembre de l'Année en années révolues si né au XXème siècle\n# On trouve quelques valeurs aberrantes correspondant à des NIr non conventionnels par ex 8041620130028\nextraire.nir <- function(Base, Année)  {\n  age <- Année - (as.numeric(substr(as.character(\n  format(Base[ , Nir], scientific = FALSE)),\n  2, 3))\n  + 1900)\n  ifelse(age < 80, age, NA)\n}\n\n\n# tester.homogeneite.matricules(Base)\n\n#  Teste si, dans une base, la proportion d'enregistrements Noms-Prénoms dont les matricules ne sont pas identiques\n#  reste inférieure à une marge de tolérance fixée (taux.tolérance.homonymie)\n#  utilité : tester si l'appariement sur Nom-Prénom au lieu de matricule sera acceptable\n\ntester.homogeneite.matricules <- function(Base) {\n\n  message(\"Contrôle sur la cohérence de l'association Nom-Prénom-Matricule (homonymies et changements de matricule)\")\n  S <- convertir.nom.prénom.majuscules(Base[ , c(\"Nom\", \"Prénom\", \"Matricule\")])\n\n  with.matr    <-   nrow(unique(S))\n  without.matr <-   nrow(unique(S[ , c(\"Nom\", \"Prénom\")]))\n\n  message(\"Matricules distincts: \", with.matr)\n  message(\"Noms-Prénoms distincs: \", without.matr)\n\n  if (with.matr  >   (1 + taux.tolérance.homonymie/100) * without.matr)\n  {\n     message(paste0(\"Résultats trop différents (\", taux.tolérance.homonymie, \" % de marge tolérée). Changement de régime de matricule.\"))\n     if (fusionner.nom.prénom == FALSE)\n       stop(\"Vous pouvez essayer de fusionner sur Nom, Prénom en spécifiant fusionner.nom.prénom <- TRUE dans prologue.R\", call. = FALSE)\n  }\n}\n\nlongueur.non.na <- function(v) length(v[!is.na(v)])\n\n# opérateurs infixe\n\n# concaténer deux strings\n\n`%+%` <- function(x, y) paste0(x,  y)\n\n`%*%` <- function(x, y) if (is.na(x) | is.na(y)) return(0) else return(x*y)\n\n# numérotation des tableaux\n\nnuméro.tableau <- 0\n\nincrément <- function() { \n  numéro.tableau <<- numéro.tableau +1 \n  numéro.tableau\n}\n\n",
    "created" : 1417027223871.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4065085547",
    "id" : "179A4374",
    "lastKnownWriteTime" : 1417027261,
    "path" : "C:/Dev/altair/Tests/Exemple/bibliotheque.fonctions.paie.R",
    "project_path" : "Tests/Exemple/bibliotheque.fonctions.paie.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}