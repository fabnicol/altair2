{
    "contents" : "#library(compiler)\n#enableJIT(3)\n\n##---------------------------------------------------------------------------------------------------------------------\n#  Chemins et variables globales du programme\n##\n\n# Cette section pourra être modifiée en entrée dans d'autres contextes\n# Matricule, Codes, Avantages en nature\n\ngénérer.codes <- TRUE\n\nchemin.dossier <- \"G:/Equipe NICOL/2013/SIERG/GESTION/2-Travail/OBSERVATIONS/ANALYSES/RH\"\n\nmatricule.categorie <- \"LISTES DES PERSONNES REMUNEREES EN 2012 PAR CATEGORIE ET STATUT.csv\"     \ncode.prime          <- \"LISTE DES RUBRIQUES DE TRAITEMENT UTILISEES EN 2012.csv\"\n#matricule.avantage  <- \"LISTE DES AGENTS AYANT BENEFICIE D'AVANTAGE EN NATURE EN 2012.csv\"\nlibellé.variable.code <- \"Code.rubrique\"\n\ncode.traitement <- 1010\n\n# Lignes de paie\n# On peut lire jusqu'à 10 fichiers csv qui seront générés au format\n#  \"chemin dossier + paies-Bulletins de paye-j.csv\"\n\nldp <- paste0(\"paies-Lignes de paye-\",1:10,\".csv\")\n\n# Bulletins de paie\n\nbdp <- \"paies-Bulletins de paye-1.csv\"\n\ncodes.NBI <- c(\"1012\", \"1011\", \"101B\", \"101M\", \"4652\", \"4672\")\n\ncolonnes.sélectionnées <- c(\"Matricule\", \"Statut\", \"Code\", \"Mois\", \"Libellé\", \"Montant\")\n\n##---------------------------------------------------------------------------------------------------------------------\noptions(width=120, warn=-1)\n\nsource(file.path(chemin.dossier, \"bibliothèque.fonctions.paie.R\"), encoding=\"UTF-8\")\n\n# Programme principal\n\n##\n#  Bases\n##\n\n# Lignes de paie\n\nldp <- ldp[file.exists(chemin(ldp))]\n\nLdp <- Read.csv(ldp)\n\n#génération du fichier des codes et libellés en privilégiant le Code\n\nif (générer.codes == TRUE) \n{\n  Codes <- Ldp[,c(\"Code\", \"Libellé\")]\n  Codes <- Codes[!duplicated(Codes),]\n  q(\"no\", 0, FALSE)\n}\n\n\n#SETDIFFLDP <- setdiff(Ldp, Ldp1)\n\n# Equivaut à :\n# ldp1 <- read.csv2(chemin.ldp1,  blank.lines.skip=TRUE, skip=1)\n# ...\n# ldp <- rbind(ldp1,ldp2,...)\n\n# Bulletin de paie\n\nBdp <- read.csv.skip(bdp)\n\n#Matricule.categorie <- read.csv.skip(matricule.categorie)\nCode.prime          <- read.csv.skip(code.prime)\n#Matricule.avantage  <- read.csv.skip(matricule.avantage)\n\n#suppression des colonnes Nom Prénom redondantes\n\n#Matricule.avantage  <- selectionner.cle.matricule(Matricule.avantage, Matricule.categorie) \nBdp                 <- selectionner.cle.matricule.mois(Bdp, Ldp)\n\n#fusion matricule | avantage | catégorie par Matricule\n\nBdp.ldp <- merge(Bdp, Ldp)\n#Bdp.ldp<-merge(Bdp.ldp, Matricule.categorie, by=c(\"Nom\"), all=TRUE)\n\n# Matricule.categorie <- selectionner.cle.matricule(Matricule.categorie, Bdp.ldp)\n# \n# # Fusion étroite\n# Base1 <- merge(Matricule.categorie, Bdp.ldp)\n# \n# # Fusion  large\n# Base2 <- merge(Matricule.categorie, Bdp.ldp, all=TRUE)\n\n##\n#  Test de cohérence sur la fusion\n##\n# \n# # Matricules différents\n# matricules.divergents <- setdiff(levels(as.factor(Base2$Matricule)), levels(as.factor(Base1$Matricule)))\n# \n# # Base correspondante\n# Base3 <- Base2[!as.character(Base2$Matricule) %in% levels(as.factor(Base1$Matricule)),]\n\nest.code.de.type <- function(x) Bdp.ldp$Code %in% Code.prime[Code.prime$Type.rémunération == x, libellé.variable.code]\n\nlibrary(plyr)\n\nBdp.ldp <- mutate(Bdp.ldp,\n       \n        montant.traitement.indiciaire = Montant*(est.code.de.type(\"TRAITEMENT\")),\n        montant.primes = Montant*(est.code.de.type(\"INDEMNITAIRE.OU.CONTRACTUEL\")),\n        montant.autres.rémunérations = Montant*(est.code.de.type(\"AUTRES\")))\n\n\nAnalyse.rémunérations <- ddply(Bdp.ldp,\n                             .(Matricule, Service),\n                             summarize,\n#                             catégorie = Code.catégorie[1],\n                             traitement.indiciaire                      = sum(montant.traitement.indiciaire),\n                             rémunération.contractuelle.ou.indemnitaire = sum(montant.primes),\n                             autres.rémunérations                       = sum(montant.autres.rémunérations),\n                             total.rémunérations                        = traitement.indiciaire \n                                                          + rémunération.contractuelle.ou.indemnitaire \n                                                          + autres.rémunérations,\n                             part.rémunération.contractuelle.ou.indemnitaire = \n                               ifelse(traitement.indiciaire + rémunération.contractuelle.ou.indemnitaire == 0, 0,\n                                           rémunération.contractuelle.ou.indemnitaire /\n                                              (traitement.indiciaire + rémunération.contractuelle.ou.indemnitaire)*100))\n\nattach(Analyse.rémunérations, warn.conflicts=FALSE)\n\n##\n#  Stats globales\n##\n\nStats <- summary(Analyse.rémunérations[total.rémunérations > 0, c(\"traitement.indiciaire\", \"rémunération.contractuelle.ou.indemnitaire\", \"autres.rémunérations\", \"total.rémunérations\", \"part.rémunération.contractuelle.ou.indemnitaire\")])\n\nmasse.indemnitaire            <- sum(rémunération.contractuelle.ou.indemnitaire[ total.rémunérations > 0])\nmasse.indiciaire              <- sum(traitement.indiciaire[ total.rémunérations > 0])\nmasse.rémunérations.brutes    <- sum(total.rémunérations[ total.rémunérations > 0])\n\nprint(data.frame(masse.indemnitaire, masse.indiciaire, masse.rémunérations.brutes))\n\ncat(\"masse totale rémunérations brutes hors élus : \", rem.brute.hors.élus <- sum(Bdp[Bdp$Service != \"Elus\",]$Brut), \"\\n\")\ncat(\"masse totale rémunérations brutes élus      : \", rem.brute.élus      <- sum(Bdp[Bdp$Service == \"Elus\",]$Brut), \"\\n\")\ncat(\"masse totale rémunérations brutes           : \", rem.brute           <- rem.brute.élus + rem.brute.hors.élus, \"\\n\")\n\ncat(\"masse salariale brutes : \", sum(Bdp.ldp$Montant), \"\\n\")\nprint(Stats)\n\n\n# Stats.C <- summary(Analyse.rémunérations[total.rémunérations > 0 & catégorie == \"C\", c(\"traitement.indiciaire\", \"rémunération.contractuelle.ou.indemnitaire\", \"autres.rémunérations\", \"total.rémunérations\", \"part.rémunération.contractuelle.ou.indemnitaire\")])\n# \n# masse.indemnitaire.C            <- sum(rémunération.contractuelle.ou.indemnitaire[ total.rémunérations > 0 & catégorie == \"C\" & ! is.na(rémunération.contractuelle.ou.indemnitaire) & ! is.na(catégorie)])\n# masse.indiciaire.C              <- sum(traitement.indiciaire[ total.rémunérations > 0 & catégorie == \"C\" & ! is.na(traitement.indiciaire) & ! is.na(catégorie)])\n# masse.rémunérations.brutes.C    <- sum(total.rémunérations[ total.rémunérations > 0 & catégorie == \"C\" & ! is.na(total.rémunérations) & ! is.na(catégorie)])\n# \n# print(data.frame(masse.indemnitaire.C, masse.indiciaire.C, masse.rémunérations.brutes.C))\n# \n# print(Stats.C)\n\n\n\n##\n#  Fonctionnaires (repérés par traitement indemnitaire > 0) : fonctionnaires stagiaires inclus (à vérif.)\n##\n\npar(las=1,\n    lab=c(15,5,6))\n\nmesure <- part.rémunération.contractuelle.ou.indemnitaire[traitement.indiciaire > 0 & part.rémunération.contractuelle.ou.indemnitaire >0]\n\nhist(mesure,\n   xlab=\"Pourcentage des indemnités dans la rémunération\\n hors politique familiale, indemnités journalières et remboursements\",\n   ylab=\"Effectif\",\n   main=\"Distribution de la part indemnitaire\\n de la rémunération annuelle des fonctionnaires\",\n   #xlim=c(min(mesure),max(mesure)+3),     \n   col=\"blue\",\n   nclass=50\n     )\n\n\n\nhist(total.rémunérations[traitement.indiciaire > 0 ]/1000,\n   xlab=\"Distribution de la rémunération en k€\\n hors politique familiale, indemnités journalières et remboursements\",\n   ylab=\"Effectif\",\n   xlim=c(0, 125),\n   main=\"Rémunération annuelle totale des fonctionnaires\",\n   col=\"blue\",\n   nclass=50\n)\n\nhist(rémunération.contractuelle.ou.indemnitaire[traitement.indiciaire > 0 ]/1000,\n     xlab=\"Distribution des attributions indemnitaires en k€\\n hors politique familiale, indemnités journalières et remboursements\",\n     ylab=\"Effectif\",\n     xlim=c(0, 45),\n     main=\"Rémunération indemnitaire annuelle des fonctionnaires\",\n     col=\"blue\",\n     breaks=50\n)\n\n# La moyenne est tirée vers le haut par les outlyers\n\nStats.fonctionnaires <- summary(Analyse.rémunérations[traitement.indiciaire > 0, c(\"traitement.indiciaire\", \"rémunération.contractuelle.ou.indemnitaire\", \"autres.rémunérations\", \"total.rémunérations\", \"part.rémunération.contractuelle.ou.indemnitaire\")])\n\nmasse.indemnitaire            <- sum(rémunération.contractuelle.ou.indemnitaire[ traitement.indiciaire > 0])\nmasse.indiciaire              <- sum(traitement.indiciaire)\nmasse.rémunérations.brutes    <- sum(total.rémunérations)\nratio.global.masse.indemnitaire  <- masse.indemnitaire/(masse.indiciaire+masse.indemnitaire)*100\n\nprint(data.frame(masse.indemnitaire, masse.indiciaire, masse.rémunérations.brutes, ratio.global.masse.indemnitaire))\n\nprint(Stats.fonctionnaires)\n\n##\n#  Contractuels (repérés par traitement indemnitaire == 0) : vacataires et stagiaires incluse\n##\n\nhist(total.rémunérations[traitement.indiciaire == 0 ]/1000,\n   xlab=\"Distribution de la rémunération en k€\",\n   ylab=\"Effectif\",\n   xlim=c(0, 4),\n   main=\"Rémunération annuelle totale des contractuels,\\n étudiants stagiaires et vacataires\",\n   col=\"red\",\n   breaks=40\n)\n\nhist(autres.rémunérations[autres.rémunérations >0],\n     xlab=\"Distribution des autres rémunérations annuelles en € :\\n politique familiale, indemnités journalières et remboursements\",\n     ylab=\"Effectif\",\n     xlim=c(0, 5000),\n     main=\"Autres rémunérations\",\n     col=\"grey\",\n     breaks=50\n)\n\n\nStats.contractuels <- summary(Analyse.rémunérations[traitement.indiciaire == 0, c(\"rémunération.contractuelle.ou.indemnitaire\", \"autres.rémunérations\", \"total.rémunérations\")])\n\nprint(Stats.contractuels)\n\ndetach(Analyse.rémunérations)\n\n##\n#  Tests réglementaires\n##\n\nattach(Bdp.ldp, warn.conflicts=FALSE)\n\n# Tests du type : incompatibilités entre indemnités et statut\n\n# NBI pour non titulaires\n\nNBI.aux.non.titulaires <- Bdp.ldp[ ! Statut %in% c(\"TITULAIRE\",\"STAGIAIRE\") & as.character(Code) %in% codes.NBI, colonnes.sélectionnées]\n\nnombre.de.ldp.NBI.nontit <- nrow(NBI.aux.non.titulaires)\n\n# heures sup >= 25h/mois\n\nHS.sup.25 <- with(Bdp, Bdp[Heures.Sup. >= 25 , c(\"Matricule\", \"Statut\", \"Mois\", \"Heures.Sup.\", \"Brut\")])\n\nnombre.de.ldp.HS.sup.25 <- nrow(HS.sup.25)\n\n# Prime de fonctions informatiques : pas dans la base de VLB\n# on cherche la chaine de char. \"INFO\" dans les libellés de primes\n# variante : filtre <- regexpr(\".*(INFO|PFI|P.F.I).*\", toupper(Bdp.ldp$Libellé)) et regmatches(Bdp.ldp$Libellé, filtre)\n\nfiltre<-grep(\".*(INFO|PFI|P.F.I).*\", Libellé)\n\npersonnels.prime.informatique <- Bdp.ldp[ filtre, colonnes.sélectionnées]\n\nprimes.informatiques.potentielles<-unique(Libellé[filtre])\n\nnombre.de.ldp.personnels.pfi <- nrow(personnels.prime.informatique)\n\n# Vacations et statut de fonctionnaire\n\nldp.fonctionnaires.et.vacations <- Bdp.ldp[ Statut %in% c(\"TITULAIRE\", \"STAGIAIRE\") & est.code.de.type(\"VACATIONS\"), colonnes.sélectionnées]\n\nnombre.de.ldp.fonctionnaires.et.vacations <- nrow(ldp.fonctionnaires.et.vacations)\n\n# Vacations et régime indemnitaire\n\nBdp.ldp.vacations <- Bdp.ldp[est.code.de.type(\"VACATIONS\"), colonnes.sélectionnées]\n\nmatricules.nontit.et.vacations <- unique(Bdp.ldp.vacations[ ! Bdp.ldp.vacations$Statut %in% c(\"TITULAIRE\", \"STAGIAIRE\"), \"Matricule\"])\n\nvacations.concernées <- Bdp.ldp.vacations[Matricule %in% matricules.nontit.et.vacations, ]\n\nRI.et.vacations <- Bdp.ldp[ Matricule %in% matricules.nontit.et.vacations & est.code.de.type(\"INDEMNITAIRE.OU.CONTRACTUEL\"), colonnes.sélectionnées]\n\ntraitement.et.vacations <- Bdp.ldp[ Matricule %in% matricules.nontit.et.vacations & est.code.de.type(\"TRAITEMENT\"), colonnes.sélectionnées]\n\nnombre.de.ldp.RI.et.vacations <- nrow(RI.et.vacations)\nnombre.de.ldp.traitement.et.vacations <- nrow(traitement.et.vacations)\n\n#IFTS et IB >= 380 (IM >= 350)\n\nfiltre.iat<-grep(\".*(IAT|I.A.T|.*Adm.*Tech).*\", Libellé, ignore.case=TRUE)\nfiltre.ifts<-grep(\".*(IFTS|I.F.T.S|.*FORF.*TRAV.*SUPP).*\", Libellé, ignore.case=TRUE)\ncodes.ifts <- unique(Bdp.ldp[filtre.ifts, \"Code\"])\n\nsélection.matricules <- intersect(!duplicated(Bdp.ldp[ Indice < 350, c(\"Matricule\")]), !duplicated( Bdp.ldp[ filtre.ifts, c(\"Matricule\")]))\n\nBdp.ldp[Matricule %in% sélection.matricules & Code %in% codes.ifts & (Indice < 350 ), colonnes.sélectionnées]\n\nrm(sélection.matricules)\n\n# IFTS et non tit\n\nifts.et.non.tit <- Bdp.ldp[Code %in% codes.ifts & !Statut %in% c(\"TITULAIRE\", \"STAGIAIRE\"), colonnes.sélectionnées]\n\n# Incomptabilités de primes entre elles\n\n#IAT et IFTS\n\npersonnels.iat.ifts <- intersect(as.character(Bdp.ldp[ filtre.iat, c(\"Matricule\")]), as.character(Bdp.ldp[ filtre.ifts, c(\"Matricule\")]))\n\nnb.personnels.iat.ifts <- length(personnels.iat.ifts)\n\n# Primes entre elles : \n\npretty.print(nombre.de.ldp.NBI.nontit)\npretty.print(nombre.de.ldp.HS.sup.25)\npretty.print(primes.informatiques.potentielles)\npretty.print(nombre.de.ldp.personnels.pfi)\npretty.print(nombre.de.ldp.fonctionnaires.et.vacations)\npretty.print(nombre.de.ldp.RI.et.vacations)\npretty.print(nombre.de.ldp.traitement.et.vacations)\npretty.print(nb.personnels.iat.ifts)\n\ndetach(Bdp.ldp)\n\n## ------------------------------------------------------------------------------------------------------------------\n#  Sauvegardes : enlever les commentaires en mode opérationnel\n##\n# \n# sauv.base(list(Analyse.rémunérations,\n# Stats.contractuels,\n# Stats.fonctionnaires,\n# Bdp.ldp,\n# #sauv.base(Base1)\n# # sauv.base(Base2, \"base2.csv\")\n# # sauv.base(Base3, \"base3.csv\")\n# # sauv.base(matricules.divergents, \"matricules.divergents.csv\")\n# # sauv.base(data.frame(masse.indemnitaire, masse.indiciaire, masse.rémunérations.brutes, ratio.global.masse.indemnitaire),\"stats.masse.csv\" )\n#  NBI.aux.non.titulaires,\n# # sauv.base(HS.sup.25, \"HS.sup.25.csv\")\n# # sauv.base(personnels.prime.informatique, \"personnels.prime.informatique.csv\")\n# ldp.fonctionnaires.et.vacations,\n# matricules.nontit.et.vacations,\n# Bdp.ldp.vacations))\n",
    "created" : 1395311404980.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "123358612",
    "id" : "5ABDF77A",
    "lastKnownWriteTime" : 1395664619,
    "path" : "G:/Equipe NICOL/2013/SIERG/GESTION/2-Travail/OBSERVATIONS/ANALYSES/RH/sierg.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}