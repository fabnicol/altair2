---
title: "RH Sierg"
author: "Fabrice Nicol"
date: false
output:
html_document:
css: style.css
---

```{r echo=FALSE}
exercice <- 2012
```

Exercice `r exercice`  
`r format(Sys.Date(), "%a %d %b %Y")`  

```{r echo=FALSE}

library(compiler)
library(knitr)

options(warn=-1, verbose=FALSE, OutDec=",")

compilerOptions <- setCompilerOptions(suppressAll=TRUE)
JITlevel <- enableJIT(3)

```{r echo=FALSE, results='asis'}

# Cette section pourra être modifiée en entrée dans d'autres contextes
# Matricule, Codes, Avantages en nature 

chemin.dossier <- "~/Dev/altair/Tests/Sierg"
champ.détection.1 <- "Matricule"
champ.détection.2 <- "Code"
champ.détection.élus <- "Service"
champ.nir <- "Nir"
libellé.élus <- "Elus"

matricule.catégorie <- "LISTES DES PERSONNES REMUNEREES EN 2012 PAR CATEGORIE ET STATUT.csv"     
code.prime          <- "LISTE DES RUBRIQUES DE TRAITEMENT UTILISEES EN 2012.csv"
matricule.avantage  <- "LISTE DES AGENTS AYANT BENEFICIE D'AVANTAGE EN NATURE EN 2012.csv"
code.traitement <- 1010


ldp <- paste0(paste0(exercice,"-Lignes de paye-"),1:10,".csv")


bdp <- paste0(exercice, "-Bulletins de paye-1.csv")

codes.NBI <- c("1012", "101B", "101M", "4652", "4672")

source(file.path(chemin.dossier, "bibliothèque.fonctions.paie.R"), encoding="UTF-8-BOM")


ldp <- ldp[file.exists(chemin(ldp))]

Ldp<-Read.csv(ldp)


Bdp <- read.csv.skip(bdp)

#Matricule.catégorie <- read.csv.skip(matricule.catégorie)
Code.prime          <- read.csv.skip(code.prime)
#Matricule.avantage  <- read.csv.skip(matricule.avantage)

#suppression des colonnes Nom Prénom redondantes

#Matricule.avantage  <- selectionner.cle.matricule(Matricule.avantage, Matricule.catégorie) 
Bdp                 <- selectionner.cle.matricule.mois(Bdp, Ldp)

if (!setequal(intersect(names(Ldp), names(Bdp)), c("Mois", "Matricule")))
  stop("L'appariement ne peut se faire par les clés Matricule et Mois")


liste.matricules.fonctionnaires <- unique(Bdp[Bdp$Mois == 12 & Bdp$Statut %in% c("TITULAIRE", "STAGIAIRE"), "Matricule"])
liste.matricules.élus   <- unique(Bdp[Bdp$Mois == 12 &  Bdp[champ.détection.élus] == libellé.élus, "Matricule"])

Bdp.nir.total.hors.élus <- Bdp[Bdp$Mois == 12 & ! Bdp$Matricule %in% liste.matricules.élus, champ.nir]

Bdp.nir.fonctionnaires  <- Bdp[Bdp$Mois == 12 &   Bdp$Matricule %in% liste.matricules.fonctionnaires, champ.nir]

années.fonctionnaires   <- exercice-1-(as.numeric(substr(as.character(Bdp.nir.fonctionnaires), 2, 3)) + 1900)

années.total.hors.élus  <- exercice-1-(as.numeric(substr(as.character(Bdp.nir.total.hors.élus), 2, 3)) + 1900)
```

# 1. Statistiques de population
**Ensemble des personnels non élus**  

```{r echo=FALSE, fig.retina=2}

hist(années.total.hors.élus,
     xlab="Âge",
     xlim=c(18, 75),
     ylab="Effectif",
     main="Pyramide des âges",
     col="blue",
     nclass=50)
```



```{r echo=FALSE, results='asis'}

Résumé(années.total.hors.élus, "Âge des personnels", align='c')
```

Effectif total: `r length(années.total.hors.élus)`  

**Ensemble des fonctionnaires stagiaires et titulaires**  
 

```{r echo=FALSE, fig.retina=2}

hist(années.fonctionnaires,
     xlab="Âge",
     xlim=c(18,68),
     ylab="Effectif",
     main="Pyramide des âges des fonctionnaires",
     col="navy",
     nclass=50)
```



```{r echo=FALSE, results='asis'}

Résumé(années.fonctionnaires, "Âge des fonctionnaires", align='c')
```

  
Effectif total: `r length(années.fonctionnaires)`   
 
**Nota :** Dans les statistiques de cette section, les élus ne sont pas pris en compte.
Pyramides au 31 décembre `r exercice`  

```{r echo=FALSE}

#fusion matricule | avantage | catégorie par Matricule

Bdp.ldp <- merge(Bdp, Ldp)

library(plyr)

Bdp.ldp2 <- mutate(Bdp.ldp,
       
        montant.traitement.indiciaire = Montant*(Code %in% Code.prime[Code.prime$Type.rémunération == "TRAITEMENT","Code.rubrique"]),
        montant.primes = Montant*(Code %in% Code.prime[Code.prime$Type.rémunération == "INDEMNITAIRE.OU.CONTRACTUEL","Code.rubrique"]),
        montant.autres.rémunérations = Montant*(Code %in% Code.prime[Code.prime$Type.rémunération == "AUTRES","Code.rubrique"]),
        warn=-1
       )


Analyse.rémunérations <- ddply(Bdp.ldp2,
                             c("Matricule", "Statut", "Service"),
                             summarize,
                             traitement.indiciaire = sum(montant.traitement.indiciaire),
                             rémunération.contractuelle.ou.indemnitaire = sum(montant.primes),
                             autres.rémunérations                       = sum(montant.autres.rémunérations),
                             total.rémunérations                        = traitement.indiciaire 
                                                          + rémunération.contractuelle.ou.indemnitaire 
                                                          + autres.rémunérations,
                             part.rémunération.contractuelle.ou.indemnitaire = 
                               ifelse(traitement.indiciaire + rémunération.contractuelle.ou.indemnitaire == 0, 0,
                                           rémunération.contractuelle.ou.indemnitaire /
                                              (traitement.indiciaire + rémunération.contractuelle.ou.indemnitaire)*100))

attach(Analyse.rémunérations, warn.conflicts=FALSE)
```

# 2. Rémunérations 
## 2.1 Fonctionnaires titulaires et stagiaires

```{r echo=FALSE, fig.retina=2, fig.width=7.1}

filtre.fonctionnaire <- function (X) X[ Statut %in% c("TITULAIRE", "STAGIAIRE") & X >0 ]

hist(filtre.fonctionnaire(total.rémunérations)/1000,
   xlab="Distribution de la rémunération en k€ \n hors politique familiale, indemnités journalières et remboursements",
   ylab="Effectif",
   xlim=c(0, 120),
   main="Rémunération annuelle des fonctionnaires",
   col="blue",
   nclass=50
)
```

 

```{r echo=FALSE, fig.retina=2, fig.width=7.1}


hist(filtre.fonctionnaire(part.rémunération.contractuelle.ou.indemnitaire),
     xlab="Distribution des attributions indemnitaires en k€\n hors politique familiale, indemnités journalières et remboursements",
     ylab="Effectif",
     xlim=c(0, 70),
     main="Rémunération indemnitaire annuelle\ndes fonctionnaires",
     col="blue",
     nclass=50
)
```

   

```{r echo=FALSE, fig.retina=2, fig.width=7.1}

hist(filtre.fonctionnaire(part.rémunération.contractuelle.ou.indemnitaire),
     xlab="Pourcentage des indemnités dans la rémunération\n hors politique familiale, indemnités journalières et remboursements",
     ylab="Effectif",
     main="Distribution de la part indemnitaire\n de la rémunération annuelle des fonctionnaires",
     xlim=c(0,60),     
     col="blue",
     nclass=30
)



masse.indemnitaire            <- sum(rémunération.contractuelle.ou.indemnitaire[ traitement.indiciaire > 0])
masse.indiciaire              <- sum(traitement.indiciaire)
masse.rémunérations.brutes    <- sum(total.rémunérations)
ratio.global.masse.indemnitaire  <- masse.indemnitaire/(masse.indiciaire+masse.indemnitaire)*100
```

### Masses indemnitaires
Les résultats sont exprimés en euros.

```{r echo=FALSE, results='asis'}

 Tableau(c("Masse indiciaire", "Masse indemnitaire"),
                  masse.indiciaire, masse.indemnitaire)
```

 

```{r echo=FALSE, results='asis'}

 Tableau(c("Masse des rémunérations brutes", "Part de la masse indemnitaire"),
                   masse.rémunérations.brutes, ratio.global.masse.indemnitaire)
```

### Statistiques de position

```{r echo=FALSE, results='asis'}


 Résumé(Analyse.rémunérations[Statut %in% c("TITULAIRE", "STAGIAIRE"), 
                              c("traitement.indiciaire",
                                "rémunération.contractuelle.ou.indemnitaire",
                                "autres.rémunérations") ],
                               c("Traitement indiciaire",
                                 "Rémunération contractuelle ou indemnitaire",
                                 "Autres rémunérations"))
```



```{r echo=FALSE, results='asis'}

 Résumé(Analyse.rémunérations[Statut %in% c("TITULAIRE", "STAGIAIRE"), 
                              c( "total.rémunérations",
                                 "part.rémunération.contractuelle.ou.indemnitaire") ],
                              c("Total rémunérations",
                                "Part de la rémunération contractuelle ou indemnitaire"))
```

## 2.2 Contractuels, vacataires et stagiaires inclus

```{r echo=FALSE, fig.retina=2, fig.width=7.1}

hist(total.rémunérations[!Statut %in% c("TITULAIRE", "STAGIAIRE") & total.rémunérations > 1000]/1000,
   xlab="Distribution de la rémunération en k€ (supérieure à 1000 €)\n hors politique familiale, indemnités journalières et remboursements",
   ylab="Effectif",
   xlim=c(0, 40),
   main="Rémunération annuelle totale des contractuels",
   col="red",
   nclass=50)
```



```{r echo=FALSE, fig.retina=2, fig.width=7.1}

hist(autres.rémunérations[autres.rémunérations >0],
     xlab="Distribution des autres rémunérations annuelles en € :\n politique familiale, indemnités journalières et remboursements",
     ylab="Effectif",
     xlim=c(0, 5000),
     main="Autres rémunérations",
     col="grey")
```

### Statistiques de position

```{r echo=FALSE, results='asis'}

  Résumé(Analyse.rémunérations[! Statut %in% c("TITULAIRE", "STAGIAIRE"), 
                                                    c("rémunération.contractuelle.ou.indemnitaire", "autres.rémunérations")],
                               c("Rémunération contractuelle ou indemnitaire",
                                  "Autres rémunérations"))
```



```{r echo=FALSE, results='asis'}

  Résumé(Analyse.rémunérations[!Statut %in% c("TITULAIRE", "STAGIAIRE"), 
                                                   "total.rémunérations"],
                                                   "Total rémunérations")
detach(Analyse.rémunérations)
```

Les résultats sont exprimés en euros.

# 3. Tests réglementaires
## 3.1 Contrôle des heures supplémentaires, des NBI et primes informatiques


```{r echo=FALSE}

attach(Bdp.ldp, warn.conflicts=FALSE)

NBI.aux.non.titulaires <- Bdp.ldp[ ! Statut %in% c("TITULAIRE","STAGIAIRE") & as.character(Code) %in% codes.NBI, c("Matricule", "Statut", "Code", "Libellé", "Mois", "Montant")]

nombre.de.ldp.NBI.nontit <- nrow(NBI.aux.non.titulaires)


filtre<-grep(".*(INFO|PFI|P.F.I).*", Libellé)

personnels.prime.informatique <- Bdp.ldp[ filtre, c("Matricule", "Statut", "Code", "Libellé", "Montant")]

primes.informatiques.potentielles<-unique(Libellé[filtre])

if  (length(primes.informatiques.potentielles) == 0) 
  primes.informatiques.potentielles <- "aucune"
  
nombre.de.personnels.pfi <- nrow(personnels.prime.informatique)
```

Primes informatiques potentielles : `r primes.informatiques.potentielles`  

```{r echo=FALSE, results='asis'}

Tableau(
  c("Nombre de lignes NBI pour non titulaires",
    "Nombre de bénéficiaires de PFI"),
  nombre.de.ldp.NBI.nontit, 
  nombre.de.personnels.pfi)
```

**Nota :**  
NBI: nouvelle bonification indiciaire  
PFI: prime de fonctions informatiques  
   
## 3.2 Contrôle des vacations pour les fonctionnaires  

```{r echo=FALSE}

# Vacations et statut de fonctionnaire

lignes.fonctionnaires.et.vacations <- Bdp.ldp[ Statut %in% c("TITULAIRE", "STAGIAIRE") & Code %in% Code.prime[Code.prime$Type.rémunération == "VACATIONS","Code.rubrique"], c("Matricule", "Statut", "Code", "Libellé", "Montant")]
matricules.fonctionnaires.et.vacations <- unique(lignes.fonctionnaires.et.vacations$Matricule)
nombre.fonctionnaires.et.vacations <- length(matricules.fonctionnaires.et.vacations)
nombre.ldp.fonctionnaires.et.vacations <- nrow(lignes.fonctionnaires.et.vacations)
```



```{r echo=FALSE, results='asis'}

Tableau(
  c("Nombre de FEV",
    "Nombre de lignes de vacations pour FEV"),
  nombre.fonctionnaires.et.vacations,
  nombre.ldp.fonctionnaires.et.vacations)
```

   
**Nota:**  
FEV : fonctionnaire effectuant des vacations

## 3.3 Contrôles sur les cumuls traitement indiciaire, indemnités et vacations des contractuels

```{r echo=FALSE}

# Vacations et régime indemnitaire

lignes.contractuels.et.vacations <- Bdp.ldp[ ! Statut %in% c("TITULAIRE", "STAGIAIRE")  & Code %in% Code.prime[Code.prime$Type.rémunération == "VACATIONS","Code.rubrique"], c("Matricule", "Code", "Libellé", "Montant")]
matricules.contractuels.et.vacations <- unique(lignes.contractuels.et.vacations$Matricule)
nombre.contractuels.et.vacations <- length(matricules.contractuels.et.vacations)

RI.et.vacations <- Bdp.ldp[ Matricule %in% matricules.contractuels.et.vacations & Code %in% Code.prime[Code.prime$Type.rémunération == "INDEMNITAIRE.OU.CONTRACTUEL","Code.rubrique"], c("Matricule", "Statut", "Code", "Libellé", "Montant")]

# Vacations et indiciaire

traitement.et.vacations <- Bdp.ldp[ Matricule %in% matricules.contractuels.et.vacations & Code %in% Code.prime[Code.prime$Type.rémunération == "TRAITEMENT","Code.rubrique"], c("Matricule", "Statut", "Code", "Libellé", "Montant")]

nombre.ldp.contractuels.et.vacations <- nrow(lignes.contractuels.et.vacations)
nombre.ldp.RI.et.vacations <- nrow(RI.et.vacations)
nombre.ldp.traitement.et.vacations <- nrow(traitement.et.vacations)
```



```{r echo=FALSE, results='asis'}
Tableau(c("Nombre de CEV",
          "Nombre de lignes CEV",
          "Nombre de lignes indemnitaires pour CEV",
          "Nombre de lignes de traitement pour CEV"),
          nombre.contractuels.et.vacations,
          nombre.ldp.contractuels.et.vacations,
          nombre.ldp.RI.et.vacations,
          nombre.ldp.traitement.et.vacations)
```

   
**Nota:**  
CEV : contractuel effectuant des vacations

## 3.4 Contrôle sur les indemnités IAT et IFTS

```{r echo=FALSE}

#IAT et IFTS

filtre.iat<-grep(".*(IAT|I.A.T|.*Adm.*Tech).*", Libellé, ignore.case=TRUE)
filtre.ifts<-grep(".*(IFTS|I.F.T.S|.*FORF.*TRAV.*SUPP).*", Libellé, ignore.case=TRUE)
codes.ifts <- unique(Bdp.ldp[filtre.ifts, "Code"])

nombre.personnels.iat.ifts <- length(personnels.iat.ifts <- intersect(as.character(Bdp.ldp[ filtre.iat, c("Matricule")]), as.character(Bdp.ldp[ filtre.ifts, c("Matricule")])))
```



```{r echo=FALSE, results='asis'}

Tableau(c("Codes IFTS", "Nombre de personnels percevant IAT et IFTS"), codes.ifts, nombre.personnels.iat.ifts)
```


### Contrôle sur les IFTS pour catégories B et contractuels

```{r echo=FALSE}

#IFTS et IB >= 380 (IM >= 350)

df1 <- Bdp.ldp[ Indice < 350, c("Matricule")]
df1 <- df1[!duplicated(df1)]

df2 <- Bdp.ldp[ filtre.ifts, c("Matricule")]
df2 <- df2[!duplicated(df2)]

df3 <- intersect(df1,df2)

lignes.ifts.anormales <- Bdp.ldp[Matricule %in% df3 & Code %in% codes.ifts & (Indice < 380 ), c("Matricule", "Statut", "Code", "Libellé", "Indice", "Montant")]
nombre.lignes.ifts.anormales <- length(lignes.ifts.anormales)

rm(df1, df2, df3)
# IFTS et non tit

ifts.et.contractuel <- Bdp.ldp[Code %in% codes.ifts & ! Statut %in% c("TITULAIRE", "STAGIAIRE"), c("Matricule", "Statut", "Code", "Libellé", "Indice", "Montant")]
nombres.lignes.ifts.et.contractuel <- length(ifts.et.contractuel)
```



```{r echo=FALSE, results='asis'}

Tableau(c("Nombre de contractuels percevant des IFTS", "Nombre de lignes IFTS pour IB < 380"), nombres.lignes.ifts.et.contractuel, nombre.lignes.ifts.anormales)
```

   
**Nota:**  
IB < 380 : fonctionnaire percevant un indice brut inférieur à 380  

## 3.5 Contrôle sur les heures supplémentaires

```{r echo=FALSE}


HS.sup.25 <- Bdp.ldp[Heures.Sup. >= 25 , c("Matricule", "Statut", "Mois", "Heures.Sup.", "Brut")]
nombre.ldp.HS.sup.25 <- nrow(HS.sup.25)

# with(Base2,
#      ihts <<- Base2[! Code.catégorie %in% c("B", "C") & substr(Code,1,2) %in% c("19") & ! grepl(" ENS", Libellé), c("Matricule", "Code", "Libellé", "Montant", "Code.catégorie")]
# )

ihts <- character(0)
nombre.ihts.anormales <- length(ihts)
```



```{r echo=FALSE, results='asis'}
 
Tableau(c("Nombre de lignes HS en excès", "Nombre de lignes IHTS anormales"), nombre.ldp.HS.sup.25, nombre.ihts.anormales)
```


   
**Nota:**  
HS en excès : au-delà de 25 heures par mois  
IHTS anormales : non attribuées à des fonctionnaires de catégorie B ou C.  

****

# Annexe

```{r echo=FALSE, results='asis'}

matricules.à.identifier <- unique(data.frame(Bdp.ldp$Nom, Bdp.ldp$Prénom, Bdp.ldp$Matricule))
Catégorie <- character(length=nrow(matricules.à.identifier))
matricules.à.identifier <- cbind(matricules.à.identifier, Catégorie)
names(matricules.à.identifier) <- c("Nom", "Prénom", "Matricule", "Catégorie")

kable(matricules.à.identifier, row.names=FALSE)

detach(Bdp.ldp)

#To beautify html output run a post script as follows in the bash or in R itself
#if (file.exists("sierg.html"))
# system("sed -i -r 's/(class=\"odd\"|class=\"header\")//g' -r 's/class=\"even\"/class=\"fab\"/g' sierg.html")
```

