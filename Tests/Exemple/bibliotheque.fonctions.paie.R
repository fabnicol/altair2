# Copyright Cour des comptes, 2017
# Contributeur :
# Fabrice Nicol, années 2012 à 2017
# fabrice.nicol@crtc.ccomptes.fr
# 
# Ce logiciel est un programme informatique servant à extraire et analyser les fichiers de paye
# produits au format spécifié par l'annexe de la convention-cadre nationale de dématérialisation
# en vigueur à compter de l'année 2008.
# 
# Ce logiciel est régi par la licence CeCILL soumise au droit français et
# respectant les principes de diffusion des logiciels libres. Vous pouvez
# utiliser, modifier et/ou redistribuer ce programme sous les conditions
# de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
# sur le site "http://www.cecill.info".
# 
# En contrepartie de l'accessibilité au code source et des droits de copie,
# de modification et de redistribution accordés par cette licence, il n'est
# offert aux utilisateurs qu'une garantie limitée. Pour les mêmes raisons,
# seule une responsabilité restreinte pèse sur l'auteur du programme, le
# titulaire des droits patrimoniaux et les concédants successifs.
# 
# A cet égard l'attention de l'utilisateur est attirée sur les risques
# associés au chargement, à l'utilisation, à la modification et/ou au
# développement et à la reproduction du logiciel par l'utilisateur étant
# donné sa spécificité de logiciel libre, qui peut le rendre complexe à
# manipuler et qui le réserve donc à des développeurs et des professionnels
# avertis possédant des connaissances informatiques approfondies. Les
# utilisateurs sont donc invités à charger et tester l'adéquation du
# logiciel à leurs besoins dans des conditions permettant d'assurer la
# sécurité de leurs systèmes et ou de leurs données et, plus généralement,
# à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
# 
# Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
# pris connaissance de la licence CeCILL, et que vous en avez accepté les
# termes.
# 
# 


##
#  Fonctions auxiliaires
##

'%+%' <- function(x, y) paste0(x, y)

chemin <-  function(fichier)
  file.path(chemin.dossier.données, fichier)

#' Conversion d'un fichier de ISO-8859-15 en UTF-8
#'
#' Conversion d'un fichier de ISO-8859-15 en UTF-8
#' 
#' @param nom Chemin du fichier à encoder 
#' @param encodage.in (= encodage.entrée) Encodage du fichier de lecture 
#' @return Lancement dun appel système à iconv -t UTF-8
#' @export

file2utf8 <- function(nom, encodage.in = "ISO-8859-15")  {
 err <- system2(iconv, c("-f", encodage.in, "-t", "UTF-8", shQuote(nom), "-c", "-o", "temp"))
 if (! err)  err <- system2("mv", c("temp", shQuote(nom))) else stop("Erreur d'encodage avec iconv")
 if (err) stop("Erreur de copie fichier après encodage avec iconv")
}

#' Conversion d'un fichier en ISO-8859-15
#'
#' Conversion d'un fichier de UTF-8 en ISO-8859-15
#' 
#' @param nom Chemin du fichier à encoder 
#' @param encodage.in (= encodage.entrée) Encodage du fichier de lecture 
#' @return Lancement dun appel système à iconv -t ISO-8859-15
#' @export

file2Latin <- function(nom, encodage.in = "UTF-8")  {
  
  err <- system2(iconv, c("-f", encodage.in, "-t", "ISO-8859-15", shQuote(nom), "-c", "-o", "temp"))
  if (! err)  err <- system2("mv", c("temp", shQuote(nom))) else stop("Erreur d'encodage Latin avec iconv")
  if (err)  stop("Erreur de copie fichier après encodage Latin avec iconv")
}


#' Lecture d'une base CSV
#'
#' Lecture d'un fichier CSV et conversion en data.table.
#' Si sécuriser.types.sortie = TRUE, forçage des types en sortie.
#'
#' @param encodage Encodage de la base lue. Valeur par défaut : encodage.entrée
#' @param classes Les classes ("character", "numeric") des variables en colonnes 
#' @param drop  Rang de la colonne à supprimer
#' @param skip  Nombre de lignes à sauter en début de fichier (défaut aucune).  
#' @param rapide Booléen (= FALSE). Si TRUE, et si convertir.encodage est TRUE, convertir en UTF-8 avant lecture.     
#' @param séparateur.liste = séparateur.liste.entrée,
#' @param séparateur.décimal = séparateur.décimal.entrée,
#' @param convertir.encodage (= TRUE) convertir en encodage UTF-8 avant lecture
#' @return Une base data.table
#' @examples
#' read.csv.skip(Base, séparateur.décimal = ",")
#' @export

read.csv.skip <- function(x, encodage = encodage.entrée, classes = NA, drop = NULL, skip = 0,
                          rapide = FALSE, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée,
                          convertir.encodage = TRUE)
{
  if (! rapide) {

    T <- read.csv(x,
                   comment.char = "",
                   sep = séparateur.liste,
                   dec = séparateur.décimal,
                   colClasses = classes,
                   skip = skip, 
                    # obsolète : trouver.valeur.skip(chem, encodage, séparateur.liste = séparateur.liste, séparateur.décimal = séparateur.décimal),
                   encoding = encodage)

    if (!is.null(drop)) { T <- T[-(drop)] }

  } else {
    
    if (encodage != "UTF-8" && convertir.encodage) {
      message("La table en entrée doit être encodée en UTF-8")
      if (convertir.encodage) message("Conversion via iconv du format " %+% encodage %+% " au format UTF-8...") else stop("Arrêt : convertir l'encodage de la table en UTF-8.")
      file2utf8(chemin(x), encodage.in = encodage)
  }
      
    # data.table n'admet d'argument dec qu'à partir de la version 1.9.5 
    
    if (is.na(classes)) classes = NULL
   
    T <- try(data.table::fread(x,
                      sep = séparateur.liste,
                      dec = séparateur.décimal,
                      header = TRUE,
                      skip = skip,
                      colClasses = classes,
                      showProgress = FALSE,
                      encoding = ifelse(setOSWindows, "Latin-1", "UTF-8")))


  }

  if (sécuriser.types.sortie) {
  # procédure de vérification et de coercition des type de sortie
  # il peut arriver que data.table produise des colonnes de type différent (classes.expost) de celui qui est demandé
  # par le paramètre classes. Cela peut arriver quand un charactère est utilisé à la place d'un chiffre dans les données
  # spécifiées comme purement numériques. Le code ci-dessous corrige les cas les plus utiles.
  # Le code C++ de l'extracteur de données pourrait à terme éliminer ces risques en garantissant le type des données en sortie.
  
  if (! is.null(classes)) {
    
   classes.expost <- sapply(T, class) 
   
   test <- (classes != classes.expost)
   
   if (any(test)) {

     sapply(1:length(classes), function(x){  
              
              if (classes.expost[x] == "character" && (classes[x] == "numeric" || classes[x] == "integer")) {

                T[[x]] <<- as.numeric(gsub(",", ".", T[[x]], fixed=TRUE))
                    # <<- impératif
                
              } else if ((classes.expost[x] == "numeric" || classes.expost[x] == "integer")
                    && (classes[x] == "character")) 
                
                       T[[x]] <<- as.character(T[[x]])
     })
    }
   }
  }

return(T)
}

#' Sauv.base
#'
#' Sauvegarde d'une base data.table sous forme de fichier CSV
#' Si sécuriser.types.sortie = TRUE, forçage des types en sortie.
#'
#' @param chemin.dossier Chemin du dossier dans lequel la base sera sauvegardée
#' @param nom Nom de l'objet à sauvegarder
#' @param nom.sauv  Chaine de caractères du nom du fichier .csv sans l'extension
#' @param encodage (= encodage.sortie)  Nombre de lignes à sauter en début de fichier (défaut aucune).  
#' @param sep (= séparateur.liste.sortie) 
#' @param dec (= séparateur.décimal.sortie),
#' @param environment (= .GlobalEnv) environnement,
#' @return Une base CSV
#' @examples
#' Sauv.base("données", Base, "BaseDonnée", sep = ";", dec = ",")
#' @export
#'

Sauv.base <- function(chemin.dossier, nom, nom.sauv, Latin = FALSE, sep = séparateur.liste.sortie, dec = séparateur.décimal.sortie, environment = .GlobalEnv)
{
  message("Sauvegarde de ", nom.sauv)
 
  filepath <- file.path(chemin.dossier, nom.sauv) %+% ".csv"
  
  L <- get(nom, envir = environment)
  
  if (! is.list(L) || (is.data.frame(L) && nrow(L) == 0)) L <- list(0)
  
  data.table::fwrite(L,
             filepath, 
             sep = sep,
             dec = dec)

  if (Latin) {
    file2Latin(filepath)
    message("Conversion de ", nom.sauv, " en encodage ISO-8859-15")
  }
}

sauv.bases <- function(dossier, env, ...)
{
  if (! dir.exists(dossier))
  {
    stop("Pas de dossier de travail spécifié")
  }

  tmp <- as.list(match.call())
  tmp[1] <- NULL

  message("Dans le dossier ", dossier," :")
  invisible(lapply(tmp[-c(1,2)], function(x) if (exists(x, where = env)) Sauv.base(dossier,
                                                                                   x,
                                                                                   x,
                                                                                   Latin = convertir.latin,
                                                                                   environment = env)))
}

# Utiliser une assignation globale
# car la fonction anonyme ne comporte que de variables locales

Read.csv <- function(base.string, fichiers, charger = charger.bases, colClasses = NA, skip = 0,
                     drop = NULL, séparateur.liste = séparateur.liste.entrée, séparateur.décimal = séparateur.décimal.entrée,
                     rapide = FALSE, convertir.encodage = TRUE, encodage = encodage.entrée)  {

    if (charger.bases) {

        assign(base.string,
               do.call(rbind, lapply(fichiers,
                                     read.csv.skip,
                                        classes = colClasses,
                                        skip = skip,
                                        séparateur.liste = séparateur.liste,
                                        séparateur.décimal = séparateur.décimal,
                                        drop = drop,
                                        convertir.encodage = convertir.encodage,
                                        encodage = encodage,
                                        rapide = rapide)),
               envir = .GlobalEnv)
    }
}

#' Statistiques descriptives de base (minimum, maximum et quartiles)
#' 
#' Lecture d'un fichier CSV et conversion en data.table.
#' Si sécuriser.types.sortie = TRUE, forçage des types en sortie.
#'
#' @param x Encodage de la base lue. Valeur par défaut : encodage.entrée
#' @param y Les classes ("character", "numeric") des variables en colonnes 
#' @param align  Rang de la colonne à supprimer
#' @param extra  Nombre de lignes à sauter en début de fichier (défaut aucune).  
#' @param type Booléen (= FALSE). Si TRUE, et si convertir.encodage est TRUE, convertir en UTF-8 avant lecture.     
#' @return Une base data.table
#' @examples
#' read.csv.skip(Base, séparateur.décimal = ",")
#' @export


Résumé <- function(x,y, align = 'r', extra = 0, type = "pond")  {
    
      Y <- na.omit(y)
 
      
      if (! is.list(Y) || is.data.frame(Y)) {

        if (type == "pond") {
          T <- sapply(Y, function(x) {
            q <- bigvis::weighted.quantile(x, Y$quotité.moyenne, na.rm = TRUE) 
            q <- append(q, weighted.mean(x, Y$quotité.moyenne, na.rm = TRUE), 3)
            prettyNum(q, big.mark = " ", digits = 2)
          })
          
          S <- cbind(c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum"), T)
          
        } else if (type == "standard") {
          S <- cbind(c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum"),
                     sapply(Y, function(x) prettyNum(summary(x), big.mark = " ")))
        }
        
        
        if (! missing(extra)) {
          if (extra == "length") {

             S <- cbind(S, c("", "", "", ifelse(is.vector(Y), length(Y), nrow(Y)), "", ""))
   
          } else {    
            
            if (is.numeric(extra))
              S <- cbind(S, c("", "", "", as.character(extra), "", ""))
          }
       }
               
      } else {

        if (type == "pond") {
          S <- cbind(c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum"),
                     sapply(Y, function(x) {
                                 q <- bigvis::weighted.quantile(x[[1]],
                                                   floor(x[[2]] * 1000), na.rm = TRUE)
                                 
                                 q <- append(q, weighted.mean(x[[1]], x[[2]], na.rm = TRUE), 3)
                               
                                 prettyNum(q, big.mark = " ")
                       }))
        } else if (type == "standard") {
          S <- cbind(c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum"),
                     sapply(Y, function(x) prettyNum(summary(x), big.mark = " ")))
        }
        
        if (! missing(extra) && extra == "length") {
          
           n <- ncol(S) - 1  
           temp <- S[ , 1]
           nrow.S <- length(temp)
          
           for (i in 1:n) {
               
               if (length(S[ , i + 1]) == nrow.S) {
                 temp <- cbind(temp, S[ , i + 1])

                 temp <- cbind(temp, c("", "", "", ifelse(is.vector(Y[[i]]), length(Y[[i]]), nrow(Y[[i]])), "", ""))
               } else {
                 cat("Impossible de générer le tableau : ligne manquante.")
                 return("")
               }
               

           }
           # S est de type matrix
           
           S <- temp
        }
      }

     if (length(dimnames(S)[[2]]) == length(x) + 1) {
       
       dimnames(S)[[2]] <- c("Statistique", x)

       kable(S, row.names = FALSE, align = align, booktabs = TRUE)
     } else {
       cat("Table non générée.")
     }

}

#' Tableau
#'
#' Présentation de tables sous forme de tableau d'une seule ligne de données.
#' Le tableau ne peut pas présenter plus d'une seule ligne.
#' 
#' @param x Vecteur de nom de lignes pour le tableau
#' @param ...  paramètres. Si sep.milliers est un paramètre, sa valeur est utiisée comme séparateur des milliers. Par défault, le séparateur blanc.
#' @return Base de données data.table mise en forme de tableau par la fonction knitr::kable comportant l'ensemble des paramètres mis en colonnes centrées, avec x comme noms de lignes.
#' @examples
#' Tableau(c("a", "b", "c", "d"), 1, 2, 3, 4)
#' 
#' | a | b | c | d |
#' |:-:|:-:|:-:|:-:|
#' | 1 | 2 | 3 | 4 |
#' 
#' @export
#'

Tableau <- function(x, ...)
{
  V <- c(...)
  if ("sep.milliers" %in% names(V))
  {
    sep.milliers <- V["sep.milliers"]
    V$sep.milliers <- NULL
  }  else
  sep.milliers <- " "

  T <- t(prettyNum(V, big.mark = sep.milliers))
  T <- data.table(T)
  names(T) <- x
  kable(T, row.names = FALSE, align = "c", booktabs= TRUE)
}


#' Tableau de plusieurs lignes
#'
#' Présentation de tables sous forme de tableau de plusieurs lignes de données.
#' 
#' @param colnames Vecteur de nom de colonnes pour le tableau
#' @param rownames Vecteur de nom de lignes pour le tableau
#' @param extra (= "") Si la valeur de ce paramètre est "variation", la variation relative est calculée entre le début et la fin de la période en lignes 
#' @param ...  paramètres fonctionnels uniquement. Si un paramètre n'est pas une fonction, le tableau est vide dans son ensemble
#' @return Base de données data.table mise en forme de tableau par la fonction knitr::kable comportant l'ensemble des paramètres mis en colonnes centrées, avec x comme noms de lignes.
#' @examples
#' Tableau(c("a", "b", "c", "d"), 1, 2, 3, 4)
#' 
#' | a | b | c | d |
#' |:-:|:-:|:-:|:-:|
#' | 1 | 2 | 3 | 4 |
#' 
#' @export
#'

Tableau.vertical <- function(colnames, rownames, extra = "", ...)   # extra functions in ... first labeled f
{
    tmp <- c(...)
   
    if (! all(lapply(tmp, is.function))) {
      message("all arguments must be functions")
      return("")
    }
    
    lr <- length(rownames)
    
    h <- function(x) as.numeric(sub(",",".", sub(" ", "", x, fixed=T), fixed=T))
    
    g <- function(f) {
        S <- rep("", lr)
        a <- as.character(prettyNum((h(f(rownames[lr]))/h(f(rownames[1])) - 1) * 100, digits = 3))
        if  (length(a) > 0)  S[ceiling(lr/2)] <- a else S[ceiling(lr/2)] <- ""
    
        S
    }
      
  
    if (! missing(extra) && is.character(extra) && extra == "variation") {
      T <- data.table(rownames)
      NT <- colnames[1]
      ltmp <- length(tmp)
      
      for (x in seq_len(ltmp)) {
        
        res1 <- try(T1 <- unlist(sapply(rownames, tmp[[x]])))
        res2 <- try(T2 <- g(tmp[[x]]))
        
        if (inherits(T1, 'try-error') || inherits(res2, 'try-error')) {
          cat("Impossible de générer le tableau.")
          return("")
        }
        
        # unlist est rendu nécessaire par le fait que lorsque character(0) apparaît, sapply n'arrive pas à délister.
        
        if (length(T1) == lr && length(T2) == lr) {
          
          T <- cbind(T, T1, T2)
          NT <- c(NT, colnames[[x + 1]], "Variation (%)")
          
        } else {
          cat("Il manque une ligne au moins dans la table. Annulation. [extra = variation]")
          return("")
        }
      }
    
      names(T) <- NT
      
    } else {
 
      M <- as.data.table(lapply(tmp, function(f) sapply(rownames, f)))
      
      if (nrow(M) == lr) {

        T <- cbind(rownames, M)
       # names(T) <- colnames
        
      } else {
        cat("Il manque une ligne au moins dans la table. Annulation. [extra != variation]")
        return("")
      }
    }
    
    kable(T, row.names = FALSE, align = "c", booktabs= TRUE)
}

Tableau.vertical2 <- function(colnames, rownames, ...)
{
  tmp <- list(...)
  N <- names(tmp[1])
  if (!is.null(N) && N == "digits") {
    digits = tmp[[1]]
    tmp <- tmp[-1]
  } else {
    digits = 1
  }
  
  res <- try(T <- data.frame(rownames, 
                  lapply(tmp, function(y) formatC(y, 
                                                          big.mark = " ",
                                                          width = "12",
                                                          format = "f",
                                                          digits = digits,
                                                          decimal.mark =",",
                                                          preserve.width ="common"))))
  if (inherits(res, 'try-error')) return("")
  
  names(T) <- colnames

  kable(T, row.names = FALSE, align = NULL, booktabs= TRUE)
}



v.jmois  <-  c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
v.jmois.leap  <-  c(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)

calcul.nb.jours.mois <- function(Mois, année)   if ((année - 2008) %% 4 == 0) {
    return(sum(v.jmois.leap[Mois])) 
    } else {
    return(sum(v.jmois[Mois]))
  }
    

positive <- function(X) X[!is.na(X) & X > 0]
non.null <- function(X) X[!is.na(X) & X != 0]
significatif <- function(x) !is.na(x) & abs(x) > 0.01

# obsolète

# installer.paquet <- function(paquet, rigoureusement = FALSE)
# {
#   if (missing(paquet))  return(NA_character_)
#   Paquet <- deparse(paquet)
#   if (length(find.package(Paquet, quiet = TRUE)) == 0)
#   {
#     install.packages(Paquet)
#     if (length(find.package(Paquet, quiet = TRUE)) !=0 )
#     {
#       message(Paquet, " a été installé.")
#       return(invisible(1))
#     }
#     else
#     {
#       message(Paquet, " n'a pas été installé.")
#       if (rigoureusement == TRUE)
#       {
#         message("Arrêt: le paquet ", Paquet, " n'a pas pu être installé.")
#         stop("Fin")
#       }
#       return(invisible(0))
#     }
#   }
#   else
#     message(Paquet, " est déjà installé.")
#   return(invisible(0))
# }
# 
# installer.paquets <- function(..., rigoureusement = FALSE)
# {
#   tmp <- as.list(match.call())
#   tmp[1] <- NULL
#   if (!missing(rigoureusement)) tmp[length(tmp)] <- NULL
#   if (length(tmp) == 0) return(0)
# 
#   invisible(do.call(sum, lapply(tmp, function(x) installer.paquet(x, rigoureusement))))
# }

convertir.nom.prénom.majuscules <- function(S)
{

  S[ , c("Nom", "Prénom")] <- apply(S[ , c("Nom", "Prénom")],
                                    2,
                                    function(x)
                                      toupper(chartr("éèôâçë","eeoaice", x)))


}




# tester.homogeneite.matricules(Base)

#  Teste si, dans une base, la proportion d'enregistrements Noms-Prénoms dont les matricules ne sont pas identiques
#  reste inférieure à une marge de tolérance fixée (taux.tolérance.homonymie)
#  utilité : tester si l'appariement sur Nom-Prénom au lieu de matricule sera acceptable

tester.homogeneite.matricules <- function(Base) {

  message("Contrôle sur la cohérence de l'association Nom-Prénom-Matricule (homonymies et changements de matricule)")
  S <- convertir.nom.prénom.majuscules(Base[ , c("Nom", "Prénom", "Matricule")])

  with.matr    <-   nrow(unique(S))
  without.matr <-   nrow(unique(S[ , c("Nom", "Prénom")]))

  message("Matricules distincts: ", with.matr)
  message("Noms-Prénoms distincs: ", without.matr)

  if (with.matr  >   (1 + taux.tolérance.homonymie/100) * without.matr)
  {
     message(paste0("Résultats trop différents (", taux.tolérance.homonymie, " % de marge tolérée). Changement de régime de matricule."))
     if (fusionner.nom.prénom == FALSE)
       stop("Vous pouvez essayer de fusionner sur Nom, Prénom en spécifiant fusionner.nom.prénom <- TRUE dans prologue.R", call. = FALSE)
  }
}

longueur.non.na <- function(v) if (is.vector(v)) length(v[!is.na(v)]) else if (is.data.frame(v)) nrow(na.omit(v))

# opérateurs infixe

# concaténer deux strings

`%+%` <- function(x, y) paste0(x,  y)
`..` <- function(...) list(expand.grid(...))


# saut de page

newpage <- function() {
  if (PDF == TRUE) {
  cat("\n\\newpage\n")
  } else {
  cat("<p style=\"page-break-after:always;\"></p>")
  }
}

newline <- function() {
  if (PDF == TRUE) {
    return(" \\newline ")
  } else {
    return("<br>")
  }
}

# numérotation des tableaux

numéro.tableau <- 0

incrément <- function() { 
  numéro.tableau <<- numéro.tableau + 1 
  numéro.tableau
}

chapitre <- 0

incrémenter.chapitre <- function() {
  chapitre <<- chapitre + 1
  invisible(chapitre)
}

FR <- function(x) formatC(x, big.mark = " ")

essayer <- function(X, Y) {
    
  res <- try(X, silent = FALSE)    
  
  if (inherits(res, 'try-error')) {
      cat(Y)
    } else {
      if (class(res) == "knitr_kable")
        print (res)
    }
}

'%s%' <- function(mot, N) if (N > 1) mot %+% "s"  else mot

filtre <- function(x) {
  
  if (is.na(codes[x, valeur])) return(codes[x, expression]) else return(unlist(codes[x, valeur]))
}


filtrer_Paie <- function(x, portée = NULL,  Base = Paie, Var = "Code", indic = FALSE) {

  filtre_ <- filtre(x)
  
  # En i, la variable Var ne peut pas être évaluée mais peut filtrer sur Paie[get(Var)...]
  # en by, utiliser dans c(...) directement
  
  if (is.null(portée)) {
    
    if (is.na(codes[x, valeur])) {

      P_  <- Base[grepl(filtre_, Libellé, ignore.case=TRUE, perl=TRUE)]
      
    } else {
      
      P_  <- Base[get(Var) %chin% filtre_]
    }
    
  } else {
   
    if (is.na(codes[x, valeur])) {
      
      if (indic) {
        
        P_  <- Base[ , indic := grepl(filtre_, Libellé, ignore.case=TRUE, perl=TRUE)
                   ][ , indic0 := any(indic),
                           by = c("Matricule", "Année", portée)][indic0 == TRUE][, indic0 := NULL]
      } else {
        
        P_  <- Base[ , indic0 := any(grepl(filtre_, Libellé, ignore.case=TRUE, perl=TRUE)),
                     by = c("Matricule", "Année", portée)
                   ][indic0 == TRUE][, indic0 := NULL]
      }

    } else {
      
      if (indic) {
        
        P_  <- Base[ , indic := get(Var) %chin% filtre_,
                       
                   ][ , indic0 := any(indic),
                            by = c("Matricule", "Année", portée)
                   ][indic0 == TRUE][, indic0 := NULL]
      } else {
        
        P_  <- Base[ , indic0 := any(get(Var) %chin% filtre_),
                     by = c("Matricule", "Année", portée)
                 ][indic0 == TRUE][, indic0 := NULL]
      }
    }
    
    
    
  }
  
  P_
}

