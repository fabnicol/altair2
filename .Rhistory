if (tester.lignes.bulletins.mois)
{
temp   <- ddply(Bulletins.paie[Bulletins.paie$Brut != 0 , c("Matricule", "Année") ], .(Matricule, Année),  nrow)
names(temp)[3]  <- "Mois.Bulletins"
temp2  <- ddply(unique(Lignes.paie[ , c("Matricule", "Année", "Mois") ]), .(Matricule, Année),  nrow)
names(temp2)[3] <- "Mois.Lignes"
M      <- merge(temp, temp2, all = TRUE)
M$Diff <- ifselse(is.na(M$Mois.Bulletins), 0, M$Mois.Bulletins)  - ifelse(is.na(M$Mois.Lignes), 0, M$Mois.Lignes)
Matrice.différence.bulletins.lignes.NMois <- M[M$Diff != 0, ]
if (!is.null(M) & nrow(M) > 0)
{
print(M)
rm(temp, temp2, M)
sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
stop("Le nombre de bulletins de paye est différent du nombre de mois payés en lignes de paye.
Voir Matrice.différence.bulletins.lignes.NMois.csv dans le dossier Bases")
}
if (tester.lignes.bulletins.mois) {
temp   <- ddply(Bulletins.paie[Bulletins.paie$Brut != 0 , c("Matricule", "Année") ], .(Matricule, Année),  nrow)
names(temp)[3]  <- "Mois.Bulletins"
temp2  <- ddply(unique(Lignes.paie[ , c("Matricule", "Année", "Mois") ]), .(Matricule, Année),  nrow)
names(temp2)[3] <- "Mois.Lignes"
M      <- merge(temp, temp2, all = TRUE)
M$Diff <- ifelse(is.na(M$Mois.Bulletins), 0, M$Mois.Bulletins)  - ifelse(is.na(M$Mois.Lignes), 0, M$Mois.Lignes)
Matrice.différence.bulletins.lignes.NMois <- M[M$Diff != 0, ]
if (!is.null(M) & nrow(M) > 0)    {
print(M)
rm(temp, temp2, M)
sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
stop("Le nombre de bulletins de paye est différent du nombre de mois payés en lignes de paye.
Voir Matrice.différence.bulletins.lignes.NMois.csv dans le dossier Bases")
}
if (tester.lignes.bulletins.mois) {
temp   <- ddply(Bulletins.paie[Bulletins.paie$Brut != 0 , c("Matricule", "Année") ], .(Matricule, Année),  nrow)
names(temp)[3]  <- "Mois.Bulletins"
temp2  <- ddply(unique(Lignes.paie[ , c("Matricule", "Année", "Mois") ]), .(Matricule, Année),  nrow)
names(temp2)[3] <- "Mois.Lignes"
M      <- merge(temp, temp2, all = TRUE)
M$Diff <- ifelse(is.na(M$Mois.Bulletins), 0, M$Mois.Bulletins)  - ifelse(is.na(M$Mois.Lignes), 0, M$Mois.Lignes)
Matrice.différence.bulletins.lignes.NMois <- M[M$Diff != 0, ]
if (!is.null(Matrice.différence.bulletins.lignes.NMois) & nrow(Matrice.différence.bulletins.lignes.NMois) > 0)    {
print(Matrice.différence.bulletins.lignes.NMois)
rm(temp, temp2, M)
sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
stop("Le nombre de bulletins de paye est différent du nombre de mois payés en lignes de paye.
Voir Matrice.différence.bulletins.lignes.NMois.csv dans le dossier Bases")
}
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
bulletins.paie.classes.input
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/prologue.R', echo=TRUE)
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
print(Matrice.différence.bulletins.lignes.NMois)
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
if (tester.lignes.bulletins.mois) {
temp   <- ddply(Bulletins.paie[Bulletins.paie$Net != 0 , c("Matricule", "Année") ], .(Matricule, Année),  nrow)
names(temp)[3]  <- "Mois.Bulletins"
temp2  <- ddply(unique(Lignes.paie[ , c("Matricule", "Année", "Mois") ]), .(Matricule, Année),  nrow)
names(temp2)[3] <- "Mois.Lignes"
M      <- merge(temp, temp2, all = TRUE)
M$Diff <- ifelse(is.na(M$Mois.Bulletins), 0, M$Mois.Bulletins)  - ifelse(is.na(M$Mois.Lignes), 0, M$Mois.Lignes)
Matrice.différence.bulletins.lignes.NMois <- M[M$Diff != 0, ]
if (!is.null(Matrice.différence.bulletins.lignes.NMois) & nrow(Matrice.différence.bulletins.lignes.NMois) > 0)    {
print(Matrice.différence.bulletins.lignes.NMois)
rm(temp, temp2, M)
sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
stop("Le nombre de bulletins de paye est différent du nombre de mois payés en lignes de paye.
Voir Matrice.différence.bulletins.lignes.NMois.csv dans le dossier Bases")
}
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
system.time(
Bulletins.paie.Lignes.paie <- mutate(Bulletins.paie.Lignes.paie,
montant.traitement.indiciaire
= Montant %*% Codes.paiement.traitement[Code],
montant.rémunération.principale.contractuel
= Montant %*% Codes.paiement.principal.contractuel[Code],
montant.rémunération.vacataire
= Montant %*% Codes.paiement.vacations[Code],
montant.primes
= Montant %*% Codes.paiement.indemnitaire[Code],
montant.autres.rémunérations
= Montant %*% Codes.paiement.autres[Code],
montant.indemnité.élu
= Montant %*% Codes.paiement.élu[Code],
### EQTP  ###
quotité
=  Temps.de.travail / 100
* ifelse(corriger.quotité,
ifelse(is.na(Taux), 1, Taux),
1)
* (montant.rémunération.principale.contractuel > 0
|
montant.traitement.indiciaire > 0)
* nb.mois / 12))
#'---
#'title: false
#'author: false
#'date: false
#'output:
#'html_document:
#'css: style.css
#'---
#'<p class = "centered"><img src = "Altair.bmp" /></p>
#'<p class = "title">RH Exemple</p>
#'
#+ echo = FALSE, warning = TRUE, message = FALSE
# comportement global du programme
# Lorsque l'on n'a que une ou deux années, mettre étudier.variations à FALSE
# Lorsque l'on n'étudie pas une base Xémélios, mettre étudier.tests.statutaires à FALSE
library(compiler)
options(warn = -1, verbose = FALSE, OutDec = ",")
encodage.entrée <- "ISO-8859-1"
# dans cet ordre
try(setwd("Tests/Exemple"), silent = TRUE)
source("prologue.R", encoding = encodage.entrée)
compilerOptions <- setCompilerOptions(suppressAll = TRUE)
JITlevel        <- enableJIT(2)
source(file.path(chemin.dossier, "bibliotheque.fonctions.paie.R"), encoding = encodage.entrée)
installer.paquets(knitr, plyr, ggplot2, assertthat, yaml, gtools)
library(knitr)
library(plyr)
library(ggplot2)
library(assertthat)
library(gtools)
# problème temporaire avec l'option fig.retina depuis fin mai 2014
knitr::opts_chunk$set(fig.width = 7.5, echo = FALSE, warning = FALSE, message = FALSE, results = 'asis')
dir.create(chemin.dossier.bases, recursive = TRUE)
#'<p class = "centered"><b>Exercices `r paste(début.période.sous.revue, "à", fin.période.sous.revue)` </b></p>
#'<p class = "author">Fabrice Nicol</h1>
#'
#+ echo = FALSE
#'`r format(Sys.Date(), "%a %d %b %Y")`
#'
nombre.exercices <- fin.période.sous.revue - début.période.sous.revue + 1
# Le format est jour/mois/année avec deux chiffres-séparateur-deux chiffres-séparateur-4 chiffres.
# Le séparateur peut être changé en un autre en modifiant le "/" dans date.format
# Cette section pourra être modifiée en entrée dans d'autres contextes
# Matricule, Codes
# Contrôle de cohérence
#  on vérifie que chaque code de paie est associé, dans le fichier des codes de paiement (par défaut, racinecodes.csv),
#  que à chaque code donné on a associé un et un seul type de rémunération ("INDEMNITAIRE", "TRAITEMENT", etc.)
if (file.exists(chemin(nom.fichier.codes.paiement)))
{
Codes.paiement <- read.csv.skip(nom.fichier.codes.paiement)
if (nlevels(as.factor(Codes.paiement$Code)) != nrow(unique(Codes.paiement[ , c(étiquette.code, "Type.rémunération")])))
{
message("Davantage de types de rémunérations que de codes distincts : incohérence de la base de codes.")
V <- tapply(Codes.paiement$Type.rémunération, Codes.paiement$Code, function(x) length(unique(x)))
V <- V[V > 1]
print(unique(merge(data.frame(Code = names(V),
"Nombre de types de rémunérations distincts" = V,
row.names=NULL),
Codes.paiement[Codes.paiement$Code %in% names(V),
c(étiquette.code, "Type.rémunération")],
by = étiquette.code,
all=TRUE)))
stop("Vérifier le fichier " %+% nom.fichier.codes.paiement)
}
message("Chargement des codes de paiement.")
}
fichier.personnels.existe <- file.exists(chemin(nom.fichier.personnels))
if (fichier.personnels.existe)
{
base.personnels.catégorie <- read.csv.skip(nom.fichier.personnels)
message("Chargement du fichier des catégories statutaires des personnels.")
}
# Lignes de paie
# On peut lire jusqu'à 50 fichiers csv de lignes de paie qui seront générés au format :
# "chemin dossier + racine-Lignes de paye-j.csv" où racine est un bref identifiant du type de contrôle (exemple : "c2a-", "PEV-", ...)
lignes.paie <- nom.fichier.paie %+% "-" %+% 1:50 %+% ".csv"
lignes.paie <- lignes.paie[file.exists(chemin(lignes.paie))]
# Bulletins de paie
# On peut lire jusqu'à 10 fichiers csv de bulletins de paie qui seront générés au format :
# "chemin dossier + racine-Bulletins de paye-j.csv"
bulletins.paie <- nom.bulletin.paie %+% "-" %+% 1:10 %+% ".csv"
bulletins.paie <- bulletins.paie[file.exists(chemin(bulletins.paie))]
# Programme principal
# Bases
# Lignes de paie
# On ne retient que les bases ayant pour années au minimum début.période.sous.revue
# et au maximum fin.période.sous.revue, qui contiennent toutes les colonnes requises
# pour le contrôle
Read.csv("Lignes.paie", lignes.paie, colClasses = lignes.paie.classes.input)
if (!is.null(Lignes.paie)) message("Chargement des lignes de paie.") else stop("Chargement des lignes de paie en échec.")
Lignes.paie <- Lignes.paie[setdiff(names(Lignes.paie), c("Année.1","Mois.1","Matricule.1"))]
Read.csv("Bulletins.paie", bulletins.paie, colClasses = bulletins.paie.classes.input)
if (!is.null(Bulletins.paie)) message("Chargement des bulletins de paie.") else stop("Chargement des bulletins de paie en échec.")
Bulletins.paie <- Bulletins.paie[  Bulletins.paie$Année >= début.période.sous.revue
& Bulletins.paie$Année <= fin.période.sous.revue, ]
Lignes.paie    <- Lignes.paie[  Lignes.paie$Année >= début.période.sous.revue
& Lignes.paie$Année <= fin.période.sous.revue, ]
Bulletins.paie.contiennent.colonnes.requises <- colonnes.requises %in% names(Bulletins.paie)
if (! all(Bulletins.paie.contiennent.colonnes.requises)) {
stop("Il manque les colonnes suivantes au(x) fichier(s) Bulletins de paie :",
colonnes.requises[! Bulletins.paie.contiennent.colonnes.requises])
} else {
message("Contrôle des noms de colonne des bulletins de paie : normal.")
}
if (tester.matricules)  tester.homogeneite.matricules(Lignes.paie)
# Ce test contrôle la cohérence entre bulletins et lignes d epaie : il faut qu'à chaque bulletin de paie, il y
# ait au mois une ligne de paie associée...
if (tester.lignes.bulletins.mois) {
temp   <- ddply(Bulletins.paie[ , c("Matricule", "Année", "Mois", "Brut", "Net") ], .(Matricule, Année),
summarise,
nMois.bull = length(Mois),
nMois.brut = length(Brut[Brut != 0]),
nMois.net  = length(Net[Net != 0]))
temp2  <- ddply(unique(Lignes.paie[Lignes.paie$Code %in% Codes.paiement$Code , c("Matricule", "Année", "Mois") ]),
.(Matricule, Année),
summarise,
nMois.lignes = length(Mois))
M      <- merge(temp, temp2, all = TRUE)
M$nMois.lignes[is.na(M$nMois.lignes)] <- 0
M      <- M[M$nMois.lignes != M$nMois.bull & M$nMois.lignes != M$nMois.brut & M$nMois.lignes != M$nMois.net, ]
if (!is.null(M) & nrow(M) != 0) {
Matrice.différence.bulletins.lignes.NMois <- M
print(Matrice.différence.bulletins.lignes.NMois)
sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
stop("Le nombre de bulletins de paye est différent du nombre de mois payés en lignes de paye.
Voir Matrice.différence.bulletins.lignes.NMois.csv dans le dossier Bases")
}  else {
message("Le nombre de bulletins de paie est cohérent avec les lignes de paie en base.")
}
rm(temp, temp2, M, Matrice.différence.bulletins.lignes.NMois)
}
#   <- M[M$Diff != 0, ]
#   if (!is.null(Matrice.différence.bulletins.lignes.NMois) & nrow(Matrice.différence.bulletins.lignes.NMois) > 0)    {
#     sauv.bases(chemin.dossier.bases, "Matrice.différence.bulletins.lignes.NMois")
#   }
# }
# Lors de la PREMIERE utilisation d'Altair, paramétrer générer.codes <- TRUE dans prologue.R
# pour générer les fichier des codes de paiement sous le dossier des bases (par défaut "Données").
# ce fichier est trier par ordre croissant des codes de paiement sur les trois premiers chiffres des codes
# des anomalies peuvent résiduellement apparaître avec des codes contenant des lettres, en général après
# le troisième chiffre du code.
# L'utilisateur devra alors renseigner la colonne étiquette.type.rémunération de ce fichier
if (générer.codes) {
message("Génération de la base des codes de paie et des libellés.")
codes.paiement.généré <- unique(Lignes.paie[c(étiquette.code, étiquette.libellé)])
codes.paiement.généré <- cbind(codes.paiement.généré[mixedorder(codes.paiement.généré$Code), ], character(nrow(codes.paiement.généré)))
names(codes.paiement.généré)[3] <- étiquette.Type.rémunération
sauv.bases(chemin.dossier.données, "codes.paiement.généré")
#'---
#'
#'# Tableau des codes de paiement
#'
#'##  Renseigner le type de rémunération
#'
#'Utiliser les codes : TRAITEMENT, INDEMNITAIRE, ELU, VACATIONS, AUTRES
#'
kable(codes.paiement.généré, row.names = FALSE)
#'
if (file.exists(file.path(chemin.dossier.données, "codes.paiement.généré.csv")))
message("Génération des codes : voir fichier Données/codes.paiement.généré.csv")  else
message("Les codes n'ont pas été générés.")
stop(
" Le programme est arrêté après génération de la base de codes et libellés.
Relancer Altair après avoir renseigné la troisième colonne
et placé le fichier sous le répertoire Données avec le nom " %+% nom.fichier.codes.paiement, call.=FALSE)
}
# suppression des colonnes Nom Prénom redondantes
message("Nettoyage des bases.")
sélectionner.clé("Bulletins.paie", "Lignes.paie")
# Technique : les espaces de noms sont pollués par la sélection des clés, il faut les nettoyer
# unname(Bulletins.paie$Nom) devrait marcher mais cause une génération de tableau sous RMarkdown, probablement un bug.
# utiliser attr à la place.
attr(Bulletins.paie$Nom, "names") <- NULL
attr(Bulletins.paie$Prénom, "names") <- NULL
attr(Lignes.paie$Nom, "names") <- NULL
attr(Lignes.paie$Prénom, "names") <- NULL
# Extraction de vecteurs représentant les codes de paiement par type de code (indemnitaire, traitement, vacations...)
if (exists("Codes.paiement"))
{
Map(
function(Data, type) {
assign(Data,
unique(Codes.paiement[Codes.paiement$Type.rémunération == type, c(étiquette.code, "Coefficient")]),
envir = .GlobalEnv)
Tab <- get(Data, envir = .GlobalEnv)
if (anyDuplicated(Tab[1]))
stop("Incohérence d'un code utilisé à la fois comme paiement et retenue.")
V <- Tab[[2]]
names(V) <- Tab[[1]]
assign(Data, V, envir = .GlobalEnv)
},
c("Codes.paiement.indemnitaire",
"Codes.paiement.principal.contractuel",
"Codes.paiement.traitement",
"Codes.paiement.élu",
"Codes.paiement.vacations",
"Codes.paiement.autres"),
c(modalité.indemnitaire,
modalité.principal.contractuel,
modalité.traitement,
modalité.élu,
modalité.vacations,
modalité.autres))
message("Extraction des codes par type de code.")
} else
stop("Charger le fichier de codes de paiement.")
# Pour assurer une fusion correcte des bulletins et lignes de paie, il importe que les colonnes communes aux deux fichiers soient
# exactement celles utilisées pour la clé d'appariement d'une part, et le tri sous chaque clé d'autre part, autrement dit :
# la clé (Matricule ou (Nom, Prénom) selon le cas) + Année + Mois
if (! setequal(intersect(names(Lignes.paie), names(Bulletins.paie)), union(c("Mois", "Année"), clé.fusion)))
{
if (fusionner.nom.prénom) {
stop("L'appariement ne peut se faire par les clés Nom, Prénom et Mois")
} else {
stop("L'appariement ne peut se faire par les clés Matricule et Mois")
}
} else {
message("Pas de redondance des colonnes des bulletins et lignes de paie : la fusion peut être réalisée.")
}
# Alternative en cas de difficulté :
#
# Bulletins.paie.Lignes.paie <- do.call(rbind, lapply(début.période.sous.revue:fin.période.sous.revue,
#                                                     function(x)
#                                                        merge(Bulletins.paie[Bulletins.paie$Année == x, ],
#                                                              Lignes.paie[Lignes.paie$Année == x, ],
#                                                              by=c(étiquette.matricule, "Mois"))))
# Lorsque les bases sont déjà chargées, ont peu désactiver le rechargement par charger.bases <- FALSE
if (charger.bases)
{
anavar <- ddply(Bulletins.paie,
c(étiquette.matricule, étiquette.année),
summarise,
# partie Analyse des variations par exercice #
Montant.net = sum(Net.à.Payer),
# En principe la colonne Brut ne tient pas compte des remboursements d efrais ou des régularisations
Montant.brut = sum(Brut),
Statut = Statut[length(Net.à.Payer)],
mois.entrée = ifelse((minimum <- min(Mois)) != Inf,
minimum,
0),
mois.sortie = ifelse((maximum <- max(Mois)) != -Inf,
maximum,
0),
nb.jours = calcul.nb.jours.mois(mois.entrée[1], mois.sortie[1], Année[1]),
nb.mois  = mois.sortie[1] - mois.entrée[1] + 1)
Bulletins.paie <- merge (Bulletins.paie, anavar)
Bulletins.paie.Lignes.paie <- merge(Bulletins.paie,
Lignes.paie,
by = c(clé.fusion, "Année", "Mois"))
if (!is.null(Bulletins.paie.Lignes.paie)) message("Fusion réalisée")
if (! exists("Codes.paiement.indemnitaire"))  stop("Pas de fichier des Types de codes [INDEMNITAIRE]")
if (! exists("Codes.paiement.principal.contractuel"))  stop("Pas de fichier des Types de codes [PRINCIPAL.CONTRACTUEL]")
if (! exists("Codes.paiement.vacations"))  stop("Pas de fichier des Types de codes [VACATAIRE]")
if (! exists("Codes.paiement.traitement"))    stop("Pas de fichier des Types de codes [TRAITEMENT]")
if (! exists("Codes.paiement.élu"))           stop("Pas de fichier des Types de codes [ELU]")
if (! exists("Codes.paiement.autres"))        stop("Pas de fichier des Types de codes [AUTRES]")
if (extraire.population) {
Bulletins.paie.Lignes.paie <- Bulletins.paie.Lignes.paie[grepl(expression.rég.population, Bulletins.paie.Lignes.paie$Service, ignore.case=TRUE), ]
Bulletins.paie             <- Bulletins.paie[grepl(expression.rég.population, Bulletins.paie$Service, ignore.case=TRUE), ]
if (!is.null(Bulletins.paie.Lignes.paie) & !is.null(Bulletins.paie)) message("Extraction réalisée")
}
system.time(
Bulletins.paie.Lignes.paie <- mutate(Bulletins.paie.Lignes.paie,
montant.traitement.indiciaire
= Montant %*% Codes.paiement.traitement[Code],
montant.rémunération.principale.contractuel
= Montant %*% Codes.paiement.principal.contractuel[Code],
montant.rémunération.vacataire
= Montant %*% Codes.paiement.vacations[Code],
montant.primes
= Montant %*% Codes.paiement.indemnitaire[Code],
montant.autres.rémunérations
= Montant %*% Codes.paiement.autres[Code],
montant.indemnité.élu
= Montant %*% Codes.paiement.élu[Code],
### EQTP  ###
quotité
=  Temps.de.travail / 100
* ifelse(corriger.quotité,
ifelse(is.na(Taux), 1, Taux),
1)
* (montant.rémunération.principale.contractuel > 0
|
montant.traitement.indiciaire > 0)
* nb.mois / 12))
}
system.time(
Bulletins.paie.Lignes.paie <- mutate(Bulletins.paie.Lignes.paie,
montant.traitement.indiciaire
= Montant * Codes.paiement.traitement[Code],
montant.rémunération.principale.contractuel
= Montant * Codes.paiement.principal.contractuel[Code],
montant.rémunération.vacataire
= Montant * Codes.paiement.vacations[Code],
montant.primes
= Montant * Codes.paiement.indemnitaire[Code],
montant.autres.rémunérations
= Montant * Codes.paiement.autres[Code],
montant.indemnité.élu
= Montant * Codes.paiement.élu[Code],
### EQTP  ###
quotité
=  Temps.de.travail / 100
* ifelse(corriger.quotité,
ifelse(is.na(Taux), 1, Taux),
1)
* (montant.rémunération.principale.contractuel > 0
|
montant.traitement.indiciaire > 0)
* nb.mois / 12)
Bulletins.paie.Lignes.paie$montant.traitement.indiciaire[is.na(Bulletins.paie.Lignes.paie$montant.traitement.indiciaire)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.vacataire[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.vacataire)] <- 0
Bulletins.paie.Lignes.paie$montant.primes[is.na(Bulletins.paie.Lignes.paie$montant.primes)] <- 0
Bulletins.paie.Lignes.paie$montant.autres.rémunérations[is.na(Bulletins.paie.Lignes.paie$montant.autres.rémunérations)] <- 0
Bulletins.paie.Lignes.paie$montant.indemnité.élu [is.na(Bulletins.paie.Lignes.paie$montant.indemnité.élu )] <- 0)
system.time(
Bulletins.paie.Lignes.paie <- mutate(Bulletins.paie.Lignes.paie,
montant.traitement.indiciaire
= Montant * Codes.paiement.traitement[Code],
montant.rémunération.principale.contractuel
= Montant * Codes.paiement.principal.contractuel[Code],
montant.rémunération.vacataire
= Montant * Codes.paiement.vacations[Code],
montant.primes
= Montant * Codes.paiement.indemnitaire[Code],
montant.autres.rémunérations
= Montant * Codes.paiement.autres[Code],
montant.indemnité.élu
= Montant * Codes.paiement.élu[Code],
### EQTP  ###
quotité
=  Temps.de.travail / 100
* ifelse(corriger.quotité,
ifelse(is.na(Taux), 1, Taux),
1)
* (montant.rémunération.principale.contractuel > 0
|
montant.traitement.indiciaire > 0)
* nb.mois / 12)
Bulletins.paie.Lignes.paie$montant.traitement.indiciaire[is.na(Bulletins.paie.Lignes.paie$montant.traitement.indiciaire)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.vacataire[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.vacataire)] <- 0
Bulletins.paie.Lignes.paie$montant.primes[is.na(Bulletins.paie.Lignes.paie$montant.primes)] <- 0
Bulletins.paie.Lignes.paie$montant.autres.rémunérations[is.na(Bulletins.paie.Lignes.paie$montant.autres.rémunérations)] <- 0
Bulletins.paie.Lignes.paie$montant.indemnité.élu [is.na(Bulletins.paie.Lignes.paie$montant.indemnité.élu )] <- 0
)
system.time(
{ Bulletins.paie.Lignes.paie <- mutate(Bulletins.paie.Lignes.paie,
montant.traitement.indiciaire
= Montant * Codes.paiement.traitement[Code],
montant.rémunération.principale.contractuel
= Montant * Codes.paiement.principal.contractuel[Code],
montant.rémunération.vacataire
= Montant * Codes.paiement.vacations[Code],
montant.primes
= Montant * Codes.paiement.indemnitaire[Code],
montant.autres.rémunérations
= Montant * Codes.paiement.autres[Code],
montant.indemnité.élu
= Montant * Codes.paiement.élu[Code],
### EQTP  ###
quotité
=  Temps.de.travail / 100
* ifelse(corriger.quotité,
ifelse(is.na(Taux), 1, Taux),
1)
* (montant.rémunération.principale.contractuel > 0
|
montant.traitement.indiciaire > 0)
* nb.mois / 12)
Bulletins.paie.Lignes.paie$montant.traitement.indiciaire[is.na(Bulletins.paie.Lignes.paie$montant.traitement.indiciaire)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.principale.contractuel)] <- 0
Bulletins.paie.Lignes.paie$montant.rémunération.vacataire[is.na(Bulletins.paie.Lignes.paie$montant.rémunération.vacataire)] <- 0
Bulletins.paie.Lignes.paie$montant.primes[is.na(Bulletins.paie.Lignes.paie$montant.primes)] <- 0
Bulletins.paie.Lignes.paie$montant.autres.rémunérations[is.na(Bulletins.paie.Lignes.paie$montant.autres.rémunérations)] <- 0
Bulletins.paie.Lignes.paie$montant.indemnité.élu [is.na(Bulletins.paie.Lignes.paie$montant.indemnité.élu )] <- 0
}
)
Map(
function(Data, type) {
assign(Data,
unique(Codes.paiement[Codes.paiement$Type.rémunération == type, c(étiquette.code, "Coefficient")]),
envir = .GlobalEnv)
Tab <- get(Data, envir = .GlobalEnv)
if (anyDuplicated(Tab[1]))
stop("Incohérence d'un code utilisé à la fois comme paiement et retenue.")
W <- rep(0, nrow(Codes.paiement))
names(W) <- Codes.paiement[["Code"]]
W[Tab[[1]]] <- Tab[[2]]
assign(Data, W, envir = .GlobalEnv)
},
c("Codes.paiement.indemnitaire",
"Codes.paiement.principal.contractuel",
"Codes.paiement.traitement",
"Codes.paiement.élu",
"Codes.paiement.vacations",
"Codes.paiement.autres"),
c(modalité.indemnitaire,
modalité.principal.contractuel,
modalité.traitement,
modalité.élu,
modalité.vacations,
modalité.autres))
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
if (extraire.population) {
Bulletins.paie.Lignes.paie <- Bulletins.paie.Lignes.paie[grepl(expression.rég.population, Bulletins.paie.Lignes.paie$Service, ignore.case=TRUE), ]
Bulletins.paie             <- Bulletins.paie[grepl(expression.rég.population, Bulletins.paie$Service, ignore.case=TRUE), ]
if (!is.null(Bulletins.paie.Lignes.paie) & !is.null(Bulletins.paie)) message("Extraction réalisée")
}
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
Codes.paiement.indemnitaire
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/prologue.R', echo=TRUE)
source('C:/Users/fnicol/Desktop/altair/github/Tests/Exemple/exemple.R', echo=TRUE)
Bulletins.paie.Lignes.paie$Service
unique(Bulletins.paie.Lignes.paie$Service)
cat(unique(Bulletins.paie.Lignes.paie$Service))
help(cat)
cat(unique(Bulletins.paie.Lignes.paie$Service), sep="\", \"")
