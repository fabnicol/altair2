totihts.rappels = sum(nihts.cum.rappels),
totihts.rappels.ant = sum(nihts.cum.rappels.ant)),
keyby = Année]
CumHS <- merge(CumHS, TotBaseIHTS, all = TRUE, by = "Année")
},
"La base des cumuls d'IHTS par année, des régularisations et des IHTS apparemment non liquidées n'a pas pu être générée. ")
with(CumHS,
Tableau.vertical2(c("Année N", "Cumul HS N", "Cumul IHTS N", "dont du mois", "dont rappels N", "dont payés N+1"),
Année,             toths,    totihts,   totihts.hors.rappels, totihts.rappels,  totihts.rappels.ant)
)
#'
#'
if ((l <- length(v <- CumHS[toths < totihts, Année])) > 0) {
cat("Le nombre d'heures supplémentaires déclarées pour ")
cat(v, sep = ", ")
cat(" est incohérent avec le nombre d'heures IHTS payées au titre de", ifelse(l > 1, "ces", "cet"), ifelse(l > 1, "exercices. ","exercice. "))
}
#'
#'[Lien vers les données du tableau](Bases/Reglementation/CumHS.csv)
#'[Lien vers les cumuls IHTS par matricule](Bases/Reglementation/lignes.IHTS.tot.csv)
#'[Lien vers les lignes IHTS](Bases/Reglementation/lignes.IHTS.csv)
#'
Depassement.seuil.180h <- data.table()
Dépassement.seuil.220h <- data.table()
nb.agents.dépassement <- 0
nb.agents.dépassement.220h <- 0
if (utiliser.variable.Heures.Sup.) {
Depassement.seuil.180h <- Bulletins.paie[ , Nihts.tot := sum(Heures.Sup., na.rm = TRUE),
keyby = .(Matricule, Année)
][ Nihts.tot > 180 * quotité.moyenne,
.(Matricule,
Année,
quotité.moyenne,
Nihts.tot,
Emploi,
Grade,
Service)]
} else {
Depassement.seuil.180h <- Bulletins.paie[Mois == 12 , .(
Matricule,
Année,
Emploi,
Grade,
Service)
][CumBaseIHTS[ , .(Nihts.tot = sum(nihts.tot), quotité.moyenne),
by = .(Matricule, Année)
][Nihts.tot > (180 * quotité.moyenne),
.(Matricule,
Année,
quotité.moyenne,
Nihts.tot)],
on = .(Matricule, Année)]
}
nb.agents.dépassement <- uniqueN(Depassement.seuil.180h$Matricule)
if  (nb.agents.dépassement)  {
if (VERSANT_FP == "FPH") {
cat("Le seuil de 180 heures supplémentaires maximum est dépassé par ",
FR(nb.agents.dépassement), " agents.\n")
}
Depassement.seuil.220h <- Depassement.seuil.180h[Nihts.tot > 220 * quotité.moyenne]
nb.agents.dépassement.220h <- uniqueN(Depassement.seuil.220h$Matricule)
if (VERSANT_FP == "FPH" && nb.agents.dépassement.220h) {
cat(" Le seuil de 220 heures supplémentaires maximum est dépassé par ",
FR(nb.agents.dépassement.220h),
" agents.\n")
}
}
seuil.HS <- switch (VERSANT_FP,
FPH = 15,
FPT = 25)
if (utiliser.variable.Heures.Sup.) {
cat ("Les cumuls d'IHTS sont déterminés à partir de la variable Heures.Sup. ")
HS.sup.25 <- lignes.IHTS[Heures.Sup. > seuil.HS * quotité]
} else {
cat ("Les cumuls d'IHTS sont déterminés à partir des paiements de l'année, rappels compris, et des rappels payés l'année suivante. ")
HS.sup.25 <- CumBaseIHTS[nihts.tot > seuil.HS * quotité]
}
nombre.Lignes.paie.HS.sup.25 <- nrow(HS.sup.25)
ihts.cat.A <- filtrer_Paie("IHTS")[Montant != 0
& Catégorie == "A"
& Type %chin% c("R", "I", "T", "A"),
.(Matricule, Année, Mois, Statut, Grade, Heures.Sup., Libellé, Code, Type, Montant)]
nombre.ihts.cat.A <- nrow(ihts.cat.A)
message("Heures sup controlées")
#'
#'
#'&nbsp;*Tableau `r incrément()` : Heures supplémentaires au-delà des seuils*
#'
Tableau(c("Nombre de lignes HS en excès", "Nombre de lignes IHTS cat. A"),
nombre.Lignes.paie.HS.sup.25,   nombre.ihts.cat.A)
#'
#'[Lien vers la base de données Heures supplémentaires en excès du seuil de 15h (FPH) ou de 25h/mois (FPT)](Bases/Reglementation/HS.sup.25.csv)
#'[Lien vers la base de données cumuls en excès des seuils annuels de 180 h (FPH)](Bases/Reglementation/Depassement.seuil.180h.csv)
#'[Lien vers la base de données cumuls en excès des seuils annuels de 220 h (FPH)](Bases/Reglementation/Depassement.seuil.220h.csv)
#'[Lien vers la base de données IHTS versées à des fonctionnaires de cat. A](Bases/Reglementation/ihts.cat.A.csv)
#'
#'**Nota :**
#'HS en excès : au-delà de 25 heures par mois dans la FPT et 15 heures par mois dans la FPH, sauf pour certains emplois (18,3 heures par mois)
#'IHTS cat.A : attribuées à des fonctionnaires ou non-titulaires de catégorie A ou assimilés.
#'Dans les tableaux en lien les grades, emplois et service sont ceux connus en fin d'année.
#### 5.12 ELUS ####
#'
#'## `r chapitre`.12 Contrôle sur les indemnités des élus
#'
remunerations.elu <- Analyse.remunerations[ indemnités.élu > minimum.positif,
.(Matricule,
Année,
Emploi,
indemnités.élu,
acomptes,
rémunération.indemnitaire.imposable)]
remunerations.elu <- remunerations.elu[ , rémunération.indemnitaire.imposable := indemnités.élu +  rémunération.indemnitaire.imposable]
remunerations.elu <- unique(matricules[ , .(Nom,  Matricule)])[remunerations.elu, on = étiquette.matricule]
names(remunerations.elu) <- c(union(clé.fusion, "Nom"),
"Année",
"Emploi",
"Indemnités ",
"Autres ",
"Total ")
remunerations.elu <- na.omit(remunerations.elu)
#'
if (générer.table.élus)   {
if (nrow(remunerations.elu) > 0) {
kable(remunerations.elu, row.names = FALSE)
} else {
cat("Tableau des indemnités d'élu : pas de données.")
}
} else {
cat("Tableau des indemnités d'élu : non générée.")
}
#'[Lien vers la base de données Rémunérations des élus](Bases/Reglementation/remunerations.elu.csv)
#'
#### 5.13 COMPTE DE GESTION ####
#'
#'## `r chapitre`.13 Lien avec le compte de gestion
#'
#'
#'*Pour tirer pleinement profit de ces fonctionnalités, il est préférable de faire remplir, par les organismes contrôlés le tableau CSV accessible dans le bloc* **Bugdet** *de l'onglet Extra de l'application graphique, ou bien à ce lien. Voir aussi la notice* &nbsp; [![Notice](Notice.png)](Docs/Notices/fiche_tableau_budget.odt)
#'
essayer({ paye.budget.existe <-  file.exists(chemin("paye_budget.csv"))
vect <- c("Code", "Libellé", "Statut", "Type")
if (paye.budget.existe){
code.libelle <- fread(chemin("paye_budget.csv"), # Code, Libellé,  Statut, Type, Compte
sep = ";",
encoding   = "Latin-1",
col.names  = c(vect, "Compte"),
colClasses = c("character", "character", "character", "character", "character"))
message("*****")
message("Importation de la table des codes et libellés par compte (paye_budget.csv)")
message("*****")
code.libelle <- résumer_type(code.libelle)
code.libelle      <- unique(code.libelle)
cumul.lignes.paie <-  code.libelle[Paie[, .(Année, Code, Libellé, Statut, Type, Montant)],  on = vect]
} else {
# Ne pas prendre les capitales ni simplifier les libellés
code.libelle <- unique(Paie[Montant != 0, .(Code, Libellé, Statut), by = "Type"], by = NULL)
# Note : des traitements et NBI sont parfois improprement codés comme indemnités.
code.libelle[Type %chin% c("T", "I", "R", "AC") & grepl(expression.rég.traitement, Libellé, ignore.case = TRUE, perl = TRUE),
`:=`(Compte.tit    = "64111",
Compte.nontit = "64131")]
code.libelle[Type == "IR" | Type == "S" | (Type %chin% c("T", "I", "R") & grepl(expression.rég.nbi, Libellé, ignore.case = TRUE, perl = TRUE)),
`:=`(Compte.tit    = "64112",
Compte.nontit = "64132")]
code.libelle[grepl("(?:ind|prim).*(?:pr[e,é]avis|licen)", Libellé, ignore.case = TRUE, perl = TRUE),
`:=`(Compte.tit    = "64116",
Compte.nontit = "64136")]
code.libelle[is.na(Compte.tit)
& Statut != "ELU"
& ! Type %chin% c("D", "C", "RE", "CO")
& (Type == "I" | grepl("(?:prim|indem)", Libellé, ignore.case = TRUE, perl = TRUE)),
`:=`(Compte.tit    = "64118",
Compte.nontit = "64138")]
code.libelle[ , Compte := ifelse(Statut == "TITULAIRE" | Statut == "STAGIAIRE", Compte.tit, Compte.nontit)
][ , Compte.tit := NULL
][ , Compte.nontit := NULL]
cumul.lignes.paie <- code.libelle[Paie[ , .(Année, Code, Libellé, Statut, Type, Montant)], on = vect]
}
setkey(code.libelle, Type, Compte, Statut, Code, Libellé)
cumul.lignes.paie[is.na(Compte) | Compte == "", Compte := "Autres"]
cumul.lignes.paie <- cumul.lignes.paie[ , .(Total = sum(Montant, na.rm = TRUE)), keyby = .(Année, Compte, Libellé, Code)][Total != 0]
cumul.lignes.paie <- cumul.lignes.paie[ , Total2  := formatC(Total, big.mark = " ", format = "f", decimal.mark = ",", digits = 2)]
cumul.total.lignes.paie <- cumul.lignes.paie[ , .(`Cumul annuel`= formatC(sum(Total, na.rm = TRUE),
big.mark = " ",
format = "f",
decimal.mark = ",",
digits = 2)),
keyby = .(Année, Compte)]
setnames(cumul.lignes.paie[ , Total := NULL], "Total2", "Total")
if (afficher.cumuls.détaillés.lignes.paie) {
L <- split(cumul.lignes.paie, cumul.lignes.paie$Année)
for (i in 1:durée.sous.revue) {
cat("\nTableau ", incrément(), " Année ", début.période.sous.revue + i - 1)
print(kable(L[[i]][, .(Compte, Code, Libellé, Total)], row.names = FALSE, align = 'r'))
incrément()
}
}
L <- split(cumul.total.lignes.paie, cumul.total.lignes.paie$Année)
}, "La correspondance avec le compte de gestion n'a pas pu être établie.")
if (exists("L")) {
for (i in 1:durée.sous.revue) {
essayer({ cat("\nTableau ",
incrément(),
" Année ",
début.période.sous.revue + i - 1)
print(kable(L[[i]][, .(Compte, `Cumul annuel`)], row.names = FALSE, align = 'r'))
}, "Tableaux des correspondances bases de paye-budget : génération impossible pour l'année " %+% (début.période.sous.revue + i - 1))
}
} else cat("Tableaux des correspondances bases de paye-budget : génération impossible.")
rm(L)
#'
#'[Lien vers la base détaillée des cumuls des lignes de paie](Bases/Reglementation/cumul.lignes.paie.csv)
#'
#'[Lien vers la base agrégée des cumuls des lignes de paie](Bases/Reglementation/cumul.total.lignes.paie.csv)
#'
#'
#'*Avertissement : les rappels comprennent également les rappels de cotisations et déductions diverses.*
#'
#### 5.14 SFT ####
#'
#'## `r chapitre`.14 Contrôle du supplément familial de traitement
#'
#'[![Notice](Notice.png)](Docs/Notices/fiche_SFT.odt)
## La biblitothèque SFT est à revoir
if (! utiliser.cplusplus.sft)
{
source("sft.R", encoding = encodage.code.source)
sft <- sft_R
} else {
library(sft, warn.conflicts = FALSE)
sft <- function(Nb.Enfants,
Indice,
Echelon,
NBI,
Temps.de.travail,
Année,
Mois) .Call("sft_C",
Nb.Enfants,
Indice,
Echelon,
NBI,
Temps.de.travail,
Année,
Mois,
PACKAGE="sft")
}
essayer({ Paie.sans.enfant.reduit <- Paie[Type == "S"
& (is.na(Nb.Enfants) | Nb.Enfants == 0),
.(SFT.versé = sum(Montant, na.rm = TRUE)),
keyby = .(Matricule, Année, Mois)]
Paie.sans.enfant.reduit <- Paie.sans.enfant.reduit[SFT.versé > 0]
nb.écart.paiements.sft.sans.enfant <- nrow(Paie.sans.enfant.reduit)
if (nb.écart.paiements.sft.sans.enfant > 0){
cat("\nPour les agents n'ayant pas d'enfant signalé en base, il a été détecté ",
nb.écart.paiements.sft.sans.enfant,
" bulletin", ifelse(nb.écart.paiements.sft.sans.enfant == 1, "", "s"),
" de paie présentant un paiement du SFT apparemment anormal.\n", sep="")
if (afficher.table.écarts.sft)
kable(Paie.sans.enfant.reduit, row.names = FALSE, align = 'c')
} else {
cat("\nPour les agents n'ayant pas d'enfant signalé en base, il n'a été détecté aucun paiement de SFT.\n")
}
}, "Le contrôle du SFT pour les agents sans enfant n'a pas pu être réalisé.")
#'
#'[Lien vers la base des paiements de SFT à agents sans enfant signalé](Bases/Reglementation/Paie.sans.enfant.reduit.csv)
#'
# Traitement = sum(Montant[Type == "T"], na.rm = TRUE),
essayer({  Paie.enfants.réduit <- Paie[Nb.Enfants > 0 & ! is.na(Nb.Enfants) & ! is.na(Indice) & ! is.na(Heures),
.(SFT.versé = sum(Montant[Type == "S"], na.rm = TRUE),
Temps.de.travail = Temps.de.travail[1],
Indice = Indice[1],
Echelon = Echelon[1],
NBI = NBI[1],
Nb.Enfants = Nb.Enfants[1]),
keyby = .(Matricule, Année, Mois)]
SFT.controle <- with(Paie.enfants.réduit,
mapply(sft, Nb.Enfants, Indice, Echelon, NBI, Temps.de.travail, Année, Mois, USE.NAMES = FALSE))
Paie.enfants.réduit <- cbind(Paie.enfants.réduit, SFT.controle)
Paie.enfants.réduit[ , delta.SFT := SFT.versé - SFT.controle]
## Attention ne pas intégrer au sein d'un même `:=`(...) deux définitions en coréférence avec if ... else
# ou alors utiliser ifelse()  [bug de data.table]
# Paie.enfants.réduit[ , ecart := if (SFT.controle > 1) delta / SFT.controle else NA]
# On accepte un tolérance fixée dans prologue.R à tolérance.sft <- 1 euro
controle.sft <- Paie.enfants.réduit[delta.SFT > tolérance.sft,
.(delta.SFT = round(delta.SFT, 2),
SFT.versé,
SFT.controle = round(SFT.controle, 2),
Matricule,
Année,
Mois,
Indice,
NBI,
Temps.de.travail,
Nb.Enfants)]
nb.écart.paiements.sft <- nrow(controle.sft)
if (nb.écart.paiements.sft) setorder(controle.sft, -delta.SFT, Matricule, Année, Mois)
if (nb.écart.paiements.sft > 0){
cat("\nPour les agents ayant au moins un enfant, il a été détecté ",
nb.écart.paiements.sft,
" bulletin", ifelse(nb.écart.paiements.sft == 1, "", "s"),
" de paie présentant un écart de paiement du SFT supérieur à ", tolérance.sft, " euro.\n", sep="")
if (afficher.table.écarts.sft)
kable(controle.sft, row.names = FALSE, align = 'c')
} else {
cat("\nPour les agents ayant au moins un enfant, il n'a été détecté aucun écart de paiement sur SFT supérieur à ", tolérance.sft, " euro.\n")
}
},
"Le contrôle de liquidation du SFT pour les agents ayant au moins un enfant n'a pas pu être réalisé.")
#'
#'[Lien vers la base des écarts de paiement sur SFT](Bases/Reglementation/controle.sft.csv)
#'
message("Analyse du SFT")
# data.table here overallocates memory hence inefficient !
# Bulletins.paie[Nb.Enfants > 0 , SFT.controle := sft(Nb.Enfants, Indice, Heures, Année, Mois)]
#### 5.15 ASTREINTES ####
#'
#'## `r chapitre`.15 Contrôle des indemnités pour astreintes
#'
#'[![Notice](Notice.png)](Docs/Notices/fiche_astreintes.odt)
#'
essayer({  Paie_astreintes <- filtrer_Paie("ASTREINTES", portée = "Mois", indic = TRUE)
libelles.astreintes <- unique(Paie_astreintes[indic == TRUE, .(Code, Libellé)], by = NULL)
Controle_astreintes <- Paie_astreintes[! is.na(NBI)
& NBI > 0
& indic == TRUE,
.(Matricule, Année, Mois, Catégorie, Emploi, Grade, NBI, Code, Libellé, quotité, Montant)
][Paie_NBI[ , .(Matricule, Année, Mois, Code, Libellé, Montant)],
nomatch = 0,
on = .(Matricule, Année, Mois)]
Controle_astreintes <- Controle_astreintes[Catégorie == "A"
& grepl("d(?:\\.|ir)\\w*\\s*\\bg(?:\\.|\\w*n\\.?\\w*)\\s*\\b(?:des?)\\s*\\bs\\w.*",
paste(Emploi, Grade),
perl = TRUE,
ignore.case = TRUE)]
setnames(Controle_astreintes, c("Code.x", "Libellé.x", "Montant.x"), c("Code.astreinte", "Libellé.astreinte", "Montant.astreinte"))
setnames(Controle_astreintes, c("Code.y", "Libellé.y", "Montant.y"), c("Code.NBI", "Libellé.NBI", "Montant.NBI"))
nb.agents.NBI.astreintes <- uniqueN(Controle_astreintes$Matricule)
if (nrow(Controle_astreintes)) {
cat("Des astreintes sont payées à", nb.agents.NBI.astreintes, "personnels bénéficiaires de NBI")
}
Cum_astreintes <- rbind(Controle_astreintes[, round(sum(Montant.astreinte), 1),
by = "Année"],
list("Total", Controle_astreintes[, round(sum(Montant.astreinte), 1)]))
},
"Le contrôle Astreintes-NBI n'a pas pu être réalisé.")
#'
#'&nbsp;*Tableau `r incrément()` : Cumuls irréguliers NBI et astreintes (responsabilité supérieure)*
#'
essayer({  with(Cum_astreintes,
Tableau.vertical2(c("Année", "Montant astreintes irrégulières (euros)"),
Année, V1)
)
}, "Le tableau de contrôle des astreintes n'a pas pu être généré.")
#'**Nota**
#'Vérifier l'adéquation des libellés de paye d'astreinte dans le tableau en lien ci-après.
#'Définition des fonctions de responsabilité supérieure : décrets du 27 décembre 2001 et du 28 décembre 200
#'[Lien vers la base des cumuls astreintes/NBI](Bases/Reglementation/Controle_astreintes.csv)
#'[Lien vers les libellés et codes astreintes](Bases/Reglementation/libelles.astreintes.csv)
#'
essayer({ setnames(Paie_astreintes, "indic", "indic_astr")
setnames(Base.IHTS, "indic", "indic_IHTS")
Controle_astreintes_HS_irreg <- Paie_astreintes[ , .(Matricule, Année, Mois, Code, Libellé, Type,  Montant, indic_astr)
][Base.IHTS[Type %in% c("I", "A", "R"),
.(Matricule, Année, Mois, Code, Libellé, Type, Montant, indic_IHTS)],
nomatch = 0,
on = .(Matricule, Année, Mois, Code, Libellé, Type, Montant)
][indic_IHTS == TRUE | indic_astr == TRUE]
nb.agents.IHTS.astreintes <- uniqueN(Controle_astreintes_HS_irreg$Matricule)
if (nrow(Controle_astreintes_HS_irreg)) {
cat("Des astreintes sont payées à", nb.agents.IHTS.astreintes, "personnels bénéficiaires d'IHTS.")
}
Cum_astreintes_HS_irreg <- rbind(Controle_astreintes_HS_irreg[, .(round(sum(Montant[indic_astr == TRUE]), 1),
round(sum(Montant[indic_IHTS == TRUE]), 1)),
keyby = "Année"],
list("Total",
Controle_astreintes_HS_irreg[indic_astr == TRUE, round(sum(Montant), 1)],
Controle_astreintes_HS_irreg[indic_IHTS == TRUE, round(sum(Montant), 1)]))
},
"Le contrôle du cumul astreintes IHTS n'a pas pu être réalisé")
#'
#'&nbsp;*Tableau `r incrément()` : Cumuls potentiellement irréguliers IHTS et astreintes*
#'
with(Cum_astreintes_HS_irreg,
Tableau.vertical2(c("Année", "Montant astreintes potentiellement irrégulières (euros)", "Montant IHTS correspondantes"),
Année, V1, V2)
)
#'**Nota**:
#'Les cumuls peuvent être réguliers s'il y a eu des interventions non compensées en période d'astreinte.
#'[Lien vers la base des cumuls astreintes/IHTS](Bases/Reglementation/Controle_astreintes_HS_irreg.csv)
#'[Lien vers les cumuls annuels](Bases/Reglementation/Cum_astreintes_HS_irreg.csv)
rm(Base.IHTS)
#### 5.16 RETRAITES ####
#'
#'## `r chapitre`.16 Contrôle des cotisations de retraite
#'
#'[![Notice](Notice.png)](Docs/Notices/fiche_retraite.odt)
#'**Non titulaires**
#'
#'
cat("Les non titulaires ne doivent pas cotiser à la CNRACL. ")
# Les benchmark montrent que pour DEUX %chin% successifs, l'on a intérêt à chaîner les grepl plutot qu'à les coordonner
# et allonger les vecteurs de %chin% plutôt qu'à utiliser !
# Ils montrent aussi que l'on n'a pas intérêt contrairement à l'intution à commencer par extraire une matrice
# commune Paie[Type %chin% c("C", "D")] et que les gains liés à setkey sont marginaux.
Cotisations.irreg <- Paie[Type %in% c("C", "D") & Statut %in% c("NON_TITULAIRE", "AUTRE_STATUT", "EMPLOI_AIDE", "", "ELU")
][grepl("C\\.?\\s*N\\.?\\s*R\\.?\\s*A\\.?\\s*C\\.?\\s*L",
Libellé,
ignore.case = TRUE,
perl = TRUE) & Montant > 0,
.(Matricule, Année, Mois, Type, Statut, Libellé, Montant)]
#'
#'&nbsp;*Tableau `r incrément()` : Cotisations irrégulières à la CNRACL*
#'
if (! identical(Cotisations.irreg, logical(0)) & (nlignes <- nrow(Cotisations.irreg)) > 0) {
cat("Des cotisations CNRACL sont versées pour des agents non titulaires :",  nlignes, "ligne" %s% nlignes, "de paye.")
}
#'
#'
Tableau(c("Cotisations salarié", "Cotisations employeur"),
Cotisations.irreg[Type == "D", sum(Montant, na.rm = TRUE)],
Cotisations.irreg[Type == "C", sum(Montant, na.rm = TRUE)])
#'
#'[Lien vers la base des cotisations irrégulières](Bases/Reglementation/Cotisations.irreg.csv)
#'
#'
#'**Titulaires**
#'
cat("Les titulaires ne doivent pas cotiser à l'IRCANTEC. ")
Cotisations.irreg.ircantec <- Paie[Statut == "TITULAIRE" & Type %chin% c("C", "D") & grepl("I\\.?\\s*R\\.?\\s*C\\.?\\s*A\\.?\\s*N\\.?\\s*",
Libellé,
ignore.case = TRUE, perl = TRUE)
& Montant > 0,
.(Matricule, Année, Mois, Type, Libellé, Montant)]
#'
#'&nbsp;*Tableau `r incrément()` : Cotisations irrégulières à l'IRCANTEC*
#'
if (! identical(Cotisations.irreg.ircantec, logical(0)) & (nlignes <- nrow(Cotisations.irreg.ircantec)) > 0) {
cat("Des cotisations IRCANTEC sont versées pour des agents titulaires :",  nlignes, "ligne" %s% nlignes, "de paye.")
}
#'
#'
Tableau(c("Cotisations salarié", "Cotisations employeur"),
Cotisations.irreg.ircantec[Type == "D", sum(Montant, na.rm = TRUE)],
Cotisations.irreg.ircantec[Type == "C", sum(Montant, na.rm = TRUE)])
#'
#'[Lien vers la base des cotisations irrégulières](Bases/Reglementation/Cotisations.irreg.ircantec.csv)
#'
#### 5.17 PRIMES FPH ####
#'
#'## `r chapitre`.17 Primes de la fonction publique hospitalière
#'
#'[![Notice](Notice.png)](Docs/Notices/fiche_FPH.odt)
#'
#'*Les primes qui suivent ne peuvent être octroyées qu'à des fontionnaires.*
#'*Les tests portent sur les cas d'attribution à des non-titulaires (et autres statuts)*
#'
prime_FPH_test <- function(prime, prime_lit, base, expr = NULL) {
if (VERSANT_FP != "FPH") return("Non traité.")
DT <- filtrer_Paie(prime)[ , ..colonnes]
DT <- if (! is.null(expr)) {
DT[Statut == "NON_TITULAIRE" | Statut == "AUTRE_STATUT" | grepl(expr, Grade, perl = TRUE, ignore.case = TRUE)]
} else {
DT[Statut == "NON_TITULAIRE" | Statut == "AUTRE_STATUT"]
}
if (nombre.personnels.nt <- uniqueN(DT$Matricule)) {
cat("Il existe ",
FR(nombre.personnels.nt),
"agent" %s% nombre.personnels.nt,
"non titulaire" %s% nombre.personnels.nt, "percevant une", prime_lit)
}
if (nombre.personnels.nt) {
cat("Coût des anomalies ",
DT[ , sum(Montant, na.rm = TRUE)], "euros.")
}
assign(base, DT)
primes <- unique(DT$Libellé)
primes.potentielles <- if (length(primes) == 0) "aucune" else paste(primes, collapse = " ;")
}
#'**Prime spécifique**
# décret n°88-1083 du 30 novembre 1988
primes.potentielles <- prime_FPH_test("PRIME SPECIFIQUE", "prime spécifique", "personnels.prime.specifique.nt")
#'
#'Primes spécifiques : `r primes.potentielles`
#'
#'
#'[Lien vers la base de données Prime spécifique NT](Bases/Reglementation/personnels.prime.specifique.nt.csv)
#'
#'**Prime de technicité**
# décret n°91-870 du 5 septembre 1991
primes.potentielles <- prime_FPH_test("PRIME DE TECHNICITE", "prime de technicité", "personnels.prime.tech.nt")
#'
#'Primes de technicité : `r primes.potentielles`
#'
#'
#'[Lien vers la base de données Prime de technicité NT](Bases/Reglementation/personnels.prime.tech.nt.csv)
#'
#'**Indemnité forfaitaire et technique**
# décret n°2013-102 du 29 janvier 2013
primes.potentielles <- prime_FPH_test("IFT", "indemnité forfaitaire et technique", "personnels.ift.nt")
#'
#'Indemnités forfaitaire et technique : `r primes.potentielles`
#'
#'
#'[Lien vers la base de données IFT NT](Bases/Reglementation/personnels.ift.nt.csv)
#'
#'**Prime de service**
primes.potentielles <- prime_FPH_test("PRIME DE SERVICE", "prime de service", "personnels.ps.nt", expression.rég.médecin)
#'
#'Primes de service : `r primes.potentielles`
#'
#'
#'[Lien vers la base de données primes de service NT](Bases/Reglementation/personnels.ps.nt.csv)
#'   })
