<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Request interfaces</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>The curl package provides bindings to the <a href="https://curl.haxx.se/libcurl/">libcurl</a> C library for R. The package supports retrieving data in-memory, downloading to disk, or streaming using the <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/connections.html">R &ldquo;connection&rdquo; interface</a>. Some knowledge of curl is recommended to use this package. For a more user-friendly HTTP client, have a look at the  <a href="https://cran.r-project.org/package=httr/vignettes/quickstart.html">httr</a> package which builds on curl with HTTP specific tools and logic.</p>

<h2>Request interfaces</h2>

<p>The curl package implements several interfaces to retrieve data from a URL:</p>

<ul>
<li><code>curl_fetch_memory()</code>  saves response in memory</li>
<li><code>curl_download()</code> or <code>curl_fetch_disk()</code>  writes response to disk</li>
<li><code>curl()</code> or <code>curl_fetch_stream()</code> streams response data</li>
<li><code>curl_fetch_multi()</code> (Advanced) process responses via callback functions</li>
</ul>

<p>Each interface performs the same HTTP request, they only differ in how response data is processed.</p>

<h3>Getting in memory</h3>

<p>The <code>curl_fetch_memory</code> function is a blocking interface which waits for the request to complete and returns a list with all content (data, headers, status, timings) of the server response.</p>

<pre><code class="r">req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/get?foo=123&quot;)
str(req)
</code></pre>

<pre><code>List of 7
 $ url        : chr &quot;https://eu.httpbin.org/get?foo=123&quot;
 $ status_code: int 200
 $ type       : chr &quot;application/json&quot;
 $ headers    : raw [1:230] 48 54 54 50 ...
 $ modified   : POSIXct[1:1], format: NA
 $ times      : Named num [1:6] 0 0.027 0.134 0.341 0.44 ...
  ..- attr(*, &quot;names&quot;)= chr [1:6] &quot;redirect&quot; &quot;namelookup&quot; &quot;connect&quot; &quot;pretransfer&quot; ...
 $ content    : raw [1:362] 7b 0a 20 20 ...
</code></pre>

<pre><code class="r">parse_headers(req$headers)
</code></pre>

<pre><code>[1] &quot;HTTP/1.1 200 OK&quot;                        &quot;Date: Wed, 24 Jun 2020 14:48:41 GMT&quot;   
[3] &quot;Content-Type: application/json&quot;         &quot;Content-Length: 362&quot;                   
[5] &quot;Connection: keep-alive&quot;                 &quot;Server: gunicorn/19.9.0&quot;               
[7] &quot;Access-Control-Allow-Origin: *&quot;         &quot;Access-Control-Allow-Credentials: true&quot;
</code></pre>

<pre><code class="r">jsonlite::prettify(rawToChar(req$content))
</code></pre>

<pre><code>{
    &quot;args&quot;: {
        &quot;foo&quot;: &quot;123&quot;
    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;R (4.1.0 x86_64-w64-mingw32 x86_64 mingw32)&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367c9-efa6e73c26763a7c2d22dc4c&quot;
    },
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/get?foo=123&quot;
}

</code></pre>

<p>The <code>curl_fetch_memory</code> interface is the easiest interface and most powerful for building API clients. However it is not suitable for downloading really large files because it is fully in-memory. If you are expecting 100G of data, you probably need one of the other interfaces.</p>

<h3>Downloading to disk</h3>

<p>The second method is <code>curl_download</code>, which has been designed as a drop-in replacement for <code>download.file</code> in r-base. It writes the response straight to disk, which is useful for downloading (large) files.</p>

<pre><code class="r">tmp &lt;- tempfile()
curl_download(&quot;https://eu.httpbin.org/get?bar=456&quot;, tmp)
jsonlite::prettify(readLines(tmp))
</code></pre>

<pre><code>{
    &quot;args&quot;: {
        &quot;bar&quot;: &quot;456&quot;
    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;R (4.1.0 x86_64-w64-mingw32 x86_64 mingw32)&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367c9-059e6d78485662ec4bb47530&quot;
    },
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/get?bar=456&quot;
}

</code></pre>

<h3>Streaming data</h3>

<p>The most flexible interface is the <code>curl</code> function, which has been designed as a drop-in replacement for base <code>url</code>. It will create a so-called connection object, which allows for incremental (asynchronous) reading of the response.</p>

<pre><code class="r">con &lt;- curl(&quot;https://eu.httpbin.org/get&quot;)
open(con)

# Get 3 lines
out &lt;- readLines(con, n = 3)
cat(out, sep = &quot;\n&quot;)
</code></pre>

<pre><code>{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
</code></pre>

<pre><code class="r"># Get 3 more lines
out &lt;- readLines(con, n = 3)
cat(out, sep = &quot;\n&quot;)
</code></pre>

<pre><code>    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;, 
    &quot;Host&quot;: &quot;eu.httpbin.org&quot;, 
</code></pre>

<pre><code class="r"># Get remaining lines
out &lt;- readLines(con)
close(con)
cat(out, sep = &quot;\n&quot;)
</code></pre>

<pre><code>    &quot;User-Agent&quot;: &quot;R (4.1.0 x86_64-w64-mingw32 x86_64 mingw32)&quot;, 
    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367c9-71356713fe2b3be8a02cea02&quot;
  }, 
  &quot;origin&quot;: &quot;137.208.57.59&quot;, 
  &quot;url&quot;: &quot;https://eu.httpbin.org/get&quot;
}
</code></pre>

<p>The example shows how to use <code>readLines</code> on an opened connection to read <code>n</code> lines at a time. Similarly <code>readBin</code> is used to read <code>n</code> bytes at a time for stream parsing binary data.</p>

<h4>Non blocking connections</h4>

<p>As of version 2.3 it is also possible to open connections in non-blocking mode. In this case <code>readBin</code> and <code>readLines</code> will return immediately with data that is available without waiting. For non-blocking connections we use <code>isIncomplete</code> to check if the download has completed yet.</p>

<pre><code class="r"># This httpbin mirror doesn&#39;t cache
con &lt;- curl(&quot;https://nghttp2.org/httpbin/drip?duration=1&amp;numbytes=50&quot;)
open(con, &quot;rb&quot;, blocking = FALSE)
while(isIncomplete(con)){
  buf &lt;- readBin(con, raw(), 1024)
  if(length(buf)) 
    cat(&quot;received: &quot;, rawToChar(buf), &quot;\n&quot;)
}
close(con)
</code></pre>

<p>The <code>curl_fetch_stream</code> function provides a very simple wrapper around a non-blocking connection.</p>

<h3>Async requests</h3>

<p>As of <code>curl 2.0</code> the package provides an async interface which can perform multiple simultaneous requests concurrently. The <code>curl_fetch_multi</code> adds a request to a pool and returns immediately; it does not actually perform the request. </p>

<pre><code class="r">pool &lt;- new_pool()
cb &lt;- function(req){cat(&quot;done:&quot;, req$url, &quot;: HTTP:&quot;, req$status, &quot;\n&quot;)}
curl_fetch_multi(&#39;https://www.google.com&#39;, done = cb, pool = pool)
curl_fetch_multi(&#39;https://cloud.r-project.org&#39;, done = cb, pool = pool)
curl_fetch_multi(&#39;https://httpbin.org/blabla&#39;, done = cb, pool = pool)
</code></pre>

<p>When we call <code>multi_run()</code>, all scheduled requests are performed concurrently. The callback functions get triggered when each request completes.</p>

<pre><code class="r"># This actually performs requests:
out &lt;- multi_run(pool = pool)
</code></pre>

<pre><code>done: https://cloud.r-project.org/ : HTTP: 200 
done: https://www.google.com/ : HTTP: 200 
done: https://httpbin.org/blabla : HTTP: 404 
</code></pre>

<pre><code class="r">print(out)
</code></pre>

<pre><code>$success
[1] 3

$error
[1] 0

$pending
[1] 0
</code></pre>

<p>The system allows for running many concurrent non-blocking requests. However it is quite complex and requires careful specification of handler functions.</p>

<h2>Exception handling</h2>

<p>A HTTP requests can encounter two types of errors:</p>

<ol>
<li>Connection failure: network down, host not found, invalid SSL certificate, etc</li>
<li>HTTP non-success status: 401 (DENIED), 404 (NOT FOUND), 503 (SERVER PROBLEM), etc</li>
</ol>

<p>The first type of errors (connection failures) will always raise an error in R for each interface. However if the requests succeeds and the server returns a non-success HTTP status code, only <code>curl()</code> and <code>curl_download()</code> will raise an error. Let&#39;s dive a little deeper into this.</p>

<h3>Error automatically</h3>

<p>The <code>curl</code> and <code>curl_download</code> functions are safest to use because they automatically raise an error if the request was completed but the server returned a non-success (400 or higher) HTTP status. This mimics behavior of base functions <code>url</code> and <code>download.file</code>. Therefore we can safely write code like this:</p>

<pre><code class="r"># This is OK
curl_download(&#39;https://cloud.r-project.org/CRAN_mirrors.csv&#39;, &#39;mirrors.csv&#39;)
mirros &lt;- read.csv(&#39;mirrors.csv&#39;)
unlink(&#39;mirrors.csv&#39;)
</code></pre>

<p>If the HTTP request was unsuccessful, R will not continue:</p>

<pre><code class="r"># Oops! A typo in the URL!
curl_download(&#39;https://cloud.r-project.org/CRAN_mirrorZ.csv&#39;, &#39;mirrors.csv&#39;)
</code></pre>

<pre><code>## Error: HTTP error 404.
</code></pre>

<pre><code class="r">con &lt;- curl(&#39;https://cloud.r-project.org/CRAN_mirrorZ.csv&#39;)
open(con)
</code></pre>

<pre><code>## Error: HTTP error 404.
</code></pre>

<h3>Check manually</h3>

<p>When using any of the <code>curl_fetch_*</code> functions it is important to realize that these do <strong>not</strong> raise an error if the request was completed but returned a non-200 status code. When using <code>curl_fetch_memory</code> or <code>curl_fetch_disk</code> you need to implement such application logic yourself and check if the response was successful.</p>

<pre><code class="r">req &lt;- curl_fetch_memory(&#39;https://cloud.r-project.org/CRAN_mirrors.csv&#39;)
print(req$status_code)
</code></pre>

<pre><code>[1] 200
</code></pre>

<p>Same for downloading to disk. If you do not check your status, you might have downloaded an error page!</p>

<pre><code class="r"># Oops a typo!
req &lt;- curl_fetch_disk(&#39;https://cloud.r-project.org/CRAN_mirrorZ.csv&#39;, &#39;mirrors.csv&#39;)
print(req$status_code)
</code></pre>

<pre><code>[1] 404
</code></pre>

<pre><code class="r"># This is not the CSV file we were expecting!
head(readLines(&#39;mirrors.csv&#39;))
</code></pre>

<pre><code>[1] &quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//IETF//DTD HTML 2.0//EN\&quot;&gt;&quot;                    
[2] &quot;&lt;html&gt;&lt;head&gt;&quot;                                                            
[3] &quot;&lt;title&gt;404 Not Found&lt;/title&gt;&quot;                                            
[4] &quot;&lt;/head&gt;&lt;body&gt;&quot;                                                           
[5] &quot;&lt;h1&gt;Not Found&lt;/h1&gt;&quot;                                                      
[6] &quot;&lt;p&gt;The requested URL /CRAN_mirrorZ.csv was not found on this server.&lt;/p&gt;&quot;
</code></pre>

<pre><code class="r">unlink(&#39;mirrors.csv&#39;)
</code></pre>

<p>If you <em>do</em> want the <code>curl_fetch_*</code> functions to automatically raise an error, you should set the <a href="https://curl.haxx.se/libcurl/c/CURLOPT_FAILONERROR.html"><code>FAILONERROR</code></a> option to <code>TRUE</code> in the handle of the request.</p>

<pre><code class="r">h &lt;- new_handle(failonerror = TRUE)
curl_fetch_memory(&#39;https://cloud.r-project.org/CRAN_mirrorZ.csv&#39;, handle = h)
</code></pre>

<pre><code>## Error: The requested URL returned error: 404 Not Found
</code></pre>

<h2>Customizing requests</h2>

<p>By default libcurl uses HTTP GET to issue a request to an HTTP url. To send a customized request, we first need to create and configure a curl handle object that is passed to the specific download interface.  </p>

<h3>Setting handle options</h3>

<p>Creating a new handle is done using <code>new_handle</code>. After creating a handle object, we can set the libcurl options and http request headers.</p>

<pre><code class="r">h &lt;- new_handle()
handle_setopt(h, copypostfields = &quot;moo=moomooo&quot;);
handle_setheaders(h,
  &quot;Content-Type&quot; = &quot;text/moo&quot;,
  &quot;Cache-Control&quot; = &quot;no-cache&quot;,
  &quot;User-Agent&quot; = &quot;A cow&quot;
)
</code></pre>

<p>Use the <code>curl_options()</code> function to get a list of the options supported by your version of libcurl. The <a href="https://curl.haxx.se/libcurl/c/curl_easy_setopt.html">libcurl documentation</a> explains what each option does. Option names are not case sensitive.</p>

<p>It is important you check the <a href="https://curl.haxx.se/libcurl/c/curl_easy_setopt.html">libcurl documentation</a> to set options of the correct type. Options in libcurl take several types:</p>

<ul>
<li>number</li>
<li>string</li>
<li>slist (vector of strings)</li>
<li>enum (long) option</li>
</ul>

<p>The R bindings will automatically do some type checking and coercion to convert R values to appropriate libcurl option values. Logical (boolean) values in R automatically get converted to <code>0</code> or <code>1</code> for example <a href="https://curl.haxx.se/libcurl/c/CURLOPT_VERBOSE.html">CURLOPT_VERBOSE</a>:</p>

<pre><code class="r">handle &lt;- new_handle(verbose = TRUE)
</code></pre>

<p>However R does not know if an option is actually boolean. So passing <code>TRUE</code>/ <code>FALSE</code> to any numeric option will simply set it to <code>0</code> or <code>1</code> without a warning or error. If an option value cannot be coerced, you get an error:</p>

<pre><code class="r"># URLOPT_MASFILESIZE must be a number
handle_setopt(handle, maxfilesize = &quot;foo&quot;)
</code></pre>

<pre><code>## Error: Value for option maxfilesize (114) must be a number.
</code></pre>

<pre><code class="r"># CURLOPT_USERAGENT must be a string
handle_setopt(handle, useragent = 12345)
</code></pre>

<pre><code>## Error: Value for option useragent (10018) must be a string or raw vector.
</code></pre>

<h3>ENUM (long) options</h3>

<p>Some curl options take an long in C that actually corresponds to an ENUM value. </p>

<p>For example the <a href="https://curl.haxx.se/libcurl/c/CURLOPT_USE_SSL.html">CURLOPT_USE_SSL</a> docs explains that there are 4 possible values for this option: <code>CURLUSESSL_NONE</code>, <code>CURLUSESSL_TRY</code>, <code>CURLUSESSL_CONTROL</code>, and <code>CURLUSESSL_ALL</code>. To use this option you have to lookup the integer values for these enums in the symbol table. These symbol values never change, so you only need to lookup the value you need once and then hardcode the integer value in your R code.</p>

<pre><code class="r">curl::curl_symbols(&quot;CURLUSESSL&quot;)
</code></pre>

<pre><code>                  name introduced deprecated removed value type
928     CURLUSESSL_ALL     7.17.0       &lt;NA&gt;    &lt;NA&gt;     3 &lt;NA&gt;
929 CURLUSESSL_CONTROL     7.17.0       &lt;NA&gt;    &lt;NA&gt;     2 &lt;NA&gt;
930    CURLUSESSL_NONE     7.17.0       &lt;NA&gt;    &lt;NA&gt;     0 &lt;NA&gt;
931     CURLUSESSL_TRY     7.17.0       &lt;NA&gt;    &lt;NA&gt;     1 &lt;NA&gt;
</code></pre>

<p>So suppose we want to set <code>CURLOPT_USE_SSL</code> to <code>CURLUSESSL_ALL</code> we would use this R code:</p>

<pre><code class="r">handle_setopt(handle, use_ssl = 3)
</code></pre>

<h3>Disabling HTTP/2</h3>

<p>Another example is the <a href="https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_VERSION.html">CURLOPT_HTTP_VERSION</a> option. This option is needed to disable or enable HTTP/2. However some users are not aware this is actually an ENUM and not a regular numeric value!</p>

<p>The <a href="https://curl.haxx.se/libcurl/c/CURLOPT_HTTP_VERSION.html">docs</a> explain HTTP_VERSION can be set to one of several strategies for negotiating the HTTP version between client and server. Valid values are:</p>

<pre><code class="r">curl_symbols(&#39;CURL_HTTP_VERSION_&#39;)
</code></pre>

<pre><code>                                  name introduced deprecated removed value type
31               CURL_HTTP_VERSION_1_0      7.9.1       &lt;NA&gt;    &lt;NA&gt;     1 &lt;NA&gt;
32               CURL_HTTP_VERSION_1_1      7.9.1       &lt;NA&gt;    &lt;NA&gt;     2 &lt;NA&gt;
33                 CURL_HTTP_VERSION_2     7.43.0       &lt;NA&gt;    &lt;NA&gt;     3 &lt;NA&gt;
34               CURL_HTTP_VERSION_2_0     7.33.0       &lt;NA&gt;    &lt;NA&gt;     3 &lt;NA&gt;
35 CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE     7.49.0       &lt;NA&gt;    &lt;NA&gt;     5 &lt;NA&gt;
36              CURL_HTTP_VERSION_2TLS     7.47.0       &lt;NA&gt;    &lt;NA&gt;     4 &lt;NA&gt;
37                 CURL_HTTP_VERSION_3     7.66.0       &lt;NA&gt;    &lt;NA&gt;    30 &lt;NA&gt;
38              CURL_HTTP_VERSION_NONE      7.9.1       &lt;NA&gt;    &lt;NA&gt;     0 &lt;NA&gt;
</code></pre>

<p>As seen, the value <code>2</code> corresponds to <code>CURL_HTTP_VERSION_1_1</code> and <code>3</code> corresponds to <code>CURL_HTTP_VERSION_2_0</code>. </p>

<p>As of libcurl 7.62.0, the default <code>http_version</code> is <code>CURL_HTTP_VERSION_2TLS</code> which uses HTTP/2 when possible, but only for HTTPS connections. Package authors should usually leave the default to let curl select the best appropriate http protocol.</p>

<p>One exception is when writing a client for a server that seems to be running a buggy HTTP/2 server. Unfortunately this is not uncommon, and curl is a bit more picky than browsers. If you are frequently seeing <code>Error in the HTTP2 framing layer</code> error messages, then there is likely a problem with the HTTP/2 layer on the server.</p>

<p>The easiest remedy is to <strong>disable http/2</strong> for this server by forcing http 1.1 until the service has upgraded their webservers. To do so, set the <code>http_version</code> to <code>CURL_HTTP_VERSION_1_1</code> (value: <code>2</code>):</p>

<pre><code class="r"># Force using HTTP 1.1 (the number 2 is an enum value, see above)
handle_setopt(handle, http_version = 2)
</code></pre>

<p>Note that the value <code>1</code> corresponds to HTTP 1.0 which is a legacy version of HTTP that you should not use!
Code that sets <code>http_version</code> to <code>1</code> (or even <code>1.1</code> which R simply rounds to 1) is almost always a bug.</p>

<h2>Performing the request</h2>

<p>After the handle has been configured, it can be used with any of the download interfaces to perform the request. For example <code>curl_fetch_memory</code> will load store the output of the request in memory:</p>

<pre><code class="r">req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/post&quot;, handle = h)
jsonlite::prettify(rawToChar(req$content))
</code></pre>

<pre><code>{
    &quot;args&quot;: {

    },
    &quot;data&quot;: &quot;moo=moomooo&quot;,
    &quot;files&quot;: {

    },
    &quot;form&quot;: {

    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Cache-Control&quot;: &quot;no-cache&quot;,
        &quot;Content-Length&quot;: &quot;11&quot;,
        &quot;Content-Type&quot;: &quot;text/moo&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;A cow&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367ca-ab58dcd408195344188ff180&quot;
    },
    &quot;json&quot;: null,
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/post&quot;
}

</code></pre>

<p>Alternatively we can use <code>curl()</code> to read the data of via a connection interface:</p>

<pre><code class="r">con &lt;- curl(&quot;https://eu.httpbin.org/post&quot;, handle = h)
jsonlite::prettify(readLines(con))
</code></pre>

<pre><code>{
    &quot;args&quot;: {

    },
    &quot;data&quot;: &quot;moo=moomooo&quot;,
    &quot;files&quot;: {

    },
    &quot;form&quot;: {

    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Cache-Control&quot;: &quot;no-cache&quot;,
        &quot;Content-Length&quot;: &quot;11&quot;,
        &quot;Content-Type&quot;: &quot;text/moo&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;A cow&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367cb-954364629f26ed3e76aa5c11&quot;
    },
    &quot;json&quot;: null,
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/post&quot;
}

</code></pre>

<p>Or we can use <code>curl_download</code> to write the response to disk:</p>

<pre><code class="r">tmp &lt;- tempfile()
curl_download(&quot;https://eu.httpbin.org/post&quot;, destfile = tmp, handle = h)
jsonlite::prettify(readLines(tmp))
</code></pre>

<pre><code>{
    &quot;args&quot;: {

    },
    &quot;data&quot;: &quot;moo=moomooo&quot;,
    &quot;files&quot;: {

    },
    &quot;form&quot;: {

    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Cache-Control&quot;: &quot;no-cache&quot;,
        &quot;Content-Length&quot;: &quot;11&quot;,
        &quot;Content-Type&quot;: &quot;text/moo&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;A cow&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367cb-004efc70306b7e6891cf6200&quot;
    },
    &quot;json&quot;: null,
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/post&quot;
}

</code></pre>

<p>Or perform the same request with a multi pool:</p>

<pre><code class="r">curl_fetch_multi(&quot;https://eu.httpbin.org/post&quot;, handle = h, done = function(res){
  cat(&quot;Request complete! Response content:\n&quot;)
  cat(rawToChar(res$content))
})

# Perform the request
out &lt;- multi_run()
</code></pre>

<pre><code>Request complete! Response content:
{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;moo=moomooo&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;, 
    &quot;Cache-Control&quot;: &quot;no-cache&quot;, 
    &quot;Content-Length&quot;: &quot;11&quot;, 
    &quot;Content-Type&quot;: &quot;text/moo&quot;, 
    &quot;Host&quot;: &quot;eu.httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;A cow&quot;, 
    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367cc-1abe5c9cec8e2083dbfe67fe&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;137.208.57.59&quot;, 
  &quot;url&quot;: &quot;https://eu.httpbin.org/post&quot;
}
</code></pre>

<h3>Reading cookies</h3>

<p>Curl handles automatically keep track of cookies set by the server. At any given point we can use <code>handle_cookies</code> to see a list of current cookies in the handle.</p>

<pre><code class="r"># Start with a fresh handle
h &lt;- new_handle()

# Ask server to set some cookies
req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/cookies/set?foo=123&amp;bar=ftw&quot;, handle = h)
req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/cookies/set?baz=moooo&quot;, handle = h)
handle_cookies(h)
</code></pre>

<pre><code>          domain  flag path secure expiration name value
1 eu.httpbin.org FALSE    /  FALSE       &lt;NA&gt;  foo   123
2 eu.httpbin.org FALSE    /  FALSE       &lt;NA&gt;  bar   ftw
3 eu.httpbin.org FALSE    /  FALSE       &lt;NA&gt;  baz moooo
</code></pre>

<pre><code class="r"># Unset a cookie
req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/cookies/delete?foo&quot;, handle = h)
handle_cookies(h)
</code></pre>

<pre><code>          domain  flag path secure expiration name value
1 eu.httpbin.org FALSE    /  FALSE       &lt;NA&gt;  bar   ftw
2 eu.httpbin.org FALSE    /  FALSE       &lt;NA&gt;  baz moooo
</code></pre>

<p>The <code>handle_cookies</code> function returns a data frame with 7 columns as specified in the <a href="http://www.cookiecentral.com/faq/#3.5">netscape cookie file format</a>.</p>

<h3>On reusing handles</h3>

<p>In most cases you should not re-use a single handle object for more than one request. The only benefit of reusing a handle for multiple requests is to keep track of cookies set by the server (seen above). This could be needed if your server uses session cookies, but this is rare these days. Most APIs set state explicitly via http headers or parameters, rather than implicitly via cookies.</p>

<p>In recent versions of the curl package there are no performance benefits of reusing handles. The overhead of creating and configuring a new handle object is negligible. The safest way to issue multiple requests, either to a single server or multiple servers is by using a separate handle for each request (which is the default)</p>

<pre><code class="r">req1 &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/get&quot;)
req2 &lt;- curl_fetch_memory(&quot;https://www.r-project.org&quot;)
</code></pre>

<p>In past versions of this package you needed to manually use a handle to take advantage of http Keep-Alive. However as of version 2.3 this is no longer the case: curl automatically maintains global a pool of open http connections shared by all handles. When performing many requests to the same server, curl automatically uses existing connections when possible, eliminating TCP/SSL handshaking overhead:</p>

<pre><code class="r">req &lt;- curl_fetch_memory(&quot;https://api.github.com/users/ropensci&quot;)
req$times
</code></pre>

<pre><code>     redirect    namelookup       connect   pretransfer starttransfer         total 
     0.000000      0.020993      0.055478      0.099707      0.241486      0.241653 
</code></pre>

<pre><code class="r">req2 &lt;- curl_fetch_memory(&quot;https://api.github.com/users/rstudio&quot;)
req2$times
</code></pre>

<pre><code>     redirect    namelookup       connect   pretransfer starttransfer         total 
     0.000000      0.000112      0.000115      0.000211      0.136123      0.136313 
</code></pre>

<p>If you really need to re-use a handle, do note that that curl does not cleanup the handle after each request. All of the options and internal fields will linger around for all future request until explicitly reset or overwritten. This can sometimes leads to unexpected behavior.</p>

<pre><code class="r">handle_reset(h)
</code></pre>

<p>The <code>handle_reset</code> function will reset all curl options and request headers to the default values. It will <strong>not</strong> erase cookies and it will still keep alive the connections. Therefore it is good practice to call <code>handle_reset</code> after performing a request if you want to reuse the handle for a subsequent request. Still it is always safer to create a new fresh handle when possible, rather than recycling old ones.</p>

<h3>Posting forms</h3>

<p>The <code>handle_setform</code> function is used to perform a <code>multipart/form-data</code> HTTP POST request (a.k.a. posting a form). Values can be either strings, raw vectors (for binary data) or files.</p>

<pre><code class="r"># Posting multipart
h &lt;- new_handle()
handle_setform(h,
  foo = &quot;blabla&quot;,
  bar = charToRaw(&quot;boeboe&quot;),
  iris = form_data(serialize(iris, NULL), &quot;application/rda&quot;),
  description = form_file(system.file(&quot;DESCRIPTION&quot;)),
  logo = form_file(file.path(R.home(&#39;doc&#39;), &quot;html/logo.jpg&quot;), &quot;image/jpeg&quot;)
)
req &lt;- curl_fetch_memory(&quot;https://eu.httpbin.org/post&quot;, handle = h)
</code></pre>

<p>The <code>form_file</code> function is used to upload files with the form post. It has two arguments: a file path, and optionally a content-type value. If no content-type is set, curl will guess the content type of the file based on the file extension.</p>

<p>The <code>form_data</code> function is similar but simply posts a string or raw value with a custom content-type.</p>

<h3>Using pipes</h3>

<p>All of the <code>handle_xxx</code> functions return the handle object so that function calls can be chained using the popular pipe operators:</p>

<pre><code class="r">library(magrittr)

new_handle() %&gt;%
  handle_setopt(copypostfields = &quot;moo=moomooo&quot;) %&gt;%
  handle_setheaders(&quot;Content-Type&quot;=&quot;text/moo&quot;, &quot;Cache-Control&quot;=&quot;no-cache&quot;, &quot;User-Agent&quot;=&quot;A cow&quot;) %&gt;%
  curl_fetch_memory(url = &quot;https://eu.httpbin.org/post&quot;) %$% content %&gt;% 
  rawToChar %&gt;% jsonlite::prettify()
</code></pre>

<pre><code>{
    &quot;args&quot;: {

    },
    &quot;data&quot;: &quot;moo=moomooo&quot;,
    &quot;files&quot;: {

    },
    &quot;form&quot;: {

    },
    &quot;headers&quot;: {
        &quot;Accept&quot;: &quot;*/*&quot;,
        &quot;Accept-Encoding&quot;: &quot;deflate, gzip&quot;,
        &quot;Cache-Control&quot;: &quot;no-cache&quot;,
        &quot;Content-Length&quot;: &quot;11&quot;,
        &quot;Content-Type&quot;: &quot;text/moo&quot;,
        &quot;Host&quot;: &quot;eu.httpbin.org&quot;,
        &quot;User-Agent&quot;: &quot;A cow&quot;,
        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5ef367cd-24b5fe00f7a86920e3f7a9d8&quot;
    },
    &quot;json&quot;: null,
    &quot;origin&quot;: &quot;137.208.57.59&quot;,
    &quot;url&quot;: &quot;https://eu.httpbin.org/post&quot;
}

</code></pre>

</body>

</html>
